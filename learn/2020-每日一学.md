#### 2020年11月09日  周一  第46周 

(1) Vue3 框架体积，核心代码 + Composition API : 13.5kb , 最小 11.75 kb, 所有 Runtime : 22.5 kb (Vue2 是32kb) 。Vue3 新的特性：TS重写Diff算法，使用Proxy性能更优，框架体积更小；新的Compiler,通过注释标记提升框架性能；Compisition API, 模块化功能代码，摒弃 this; 更好的按需加载（得益于 Tree Shaking）；新增：Fragment、Teleport、Suspence；Vite 开发工具。

(2) 新Diff 算法：patchChildren 根据是否存在 key 进行真正的 diff; 复用真实的 dom 节点，避免不必要的性能开销；乱序时，先找到最长递增子序列作为参考，然后再移动。

(3) Map , 一种新的数据结构，常用方法，遍历，应用场景，WeakMap;

(4) 算法题01：反转字符串中的单词 III ，给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

```text
输入:"Let's take LeetCode contest"
输出:"s'teL ekat edoCteeL tsetnoc"
```

> 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有额外的空格。

```js
方法1：
export default (str)=>{
    //字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    let arr = str.split(' ');
    //对数组进行遍历，然后每个元素进行反转
    let result = arr.map( item => { return item.split('').reverse().join('')} ) 
    return result.join(' ');
}
方法2：split
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.split(' ').map( item => { 
        return item.split('').reverse().join('')} )
        .join(' ');
}
方法3：split + 正则
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.split(/\s/g).map( item => { 
        return item.split('').reverse().join('')} )
        .join(' ');
}
方法4:正则 match
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.match(/[\w']+/g).map( item => { 
        return item.match(/[\w']+/g).reverse().join('')} )
        .join(' ');
}
```

算法的本质是寻找规律并实现。如何找到算法？发现输入和输出的关系，寻找突破点。复杂的实现怎么办？实现是程序+数据结构的结合体。

#### 2020年11月10日 周二  第46周 

(1) Vue3  Composition API 的好处： 逻辑代码更少，更集中，更易扩展；更加丰富的 API 集成；对于 TS 来说，非常友好（利于类型推导）。

(2) setup 选项中没有  this,  无法访问组件声明中的属性；setup 函数接收两个参数 props 与 context; props 不可解构，context 有 attrs 、slots、emit 属性。

#### 2020年11月11日 周三  第46周 

(1) reactive "深"转换响应式副本， readonly 创建只读对象；ref 会添加一个 value 属性，ref.value = newValue; isProxy / isReactive / isReadonly & toRow / toRef / toRefs , is 开头是做判断，返回值是布尔值，to 开头的是做转换作用。

(2) Vue3 生命周期函数的变化：destroy 变成了 unmounted , beforeDetroy 变成了 beforeUnmount; 首先执行的生命周期方法是 setup() , 然后会执行 beforeCreate() 方法, created()方法 , 接着会执行 setup() 方法中的 onBeforeMount()方法 , beforeMount()方法 , 最后执行 onMounted() 方法。

(3)正则表达式修饰符：ES5中有 i - 忽略大小写，m - 多行匹配， g - 全局匹配；ES6 中 y- 粘连修饰符，u - unicode 修饰符。

