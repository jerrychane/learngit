#### 2020年11月09日  周一  第46周 

(1) Vue3 框架体积，核心代码 + Composition API : 13.5kb , 最小 11.75 kb, 所有 Runtime : 22.5 kb (Vue2 是32kb) 。Vue3 新的特性：TS重写Diff算法，使用Proxy性能更优，框架体积更小；新的Compiler,通过注释标记提升框架性能；Compisition API, 模块化功能代码，摒弃 this; 更好的按需加载（得益于 Tree Shaking）；新增：Fragment、Teleport、Suspence；Vite 开发工具。

(2) 新Diff 算法：patchChildren 根据是否存在 key 进行真正的 diff; 复用真实的 dom 节点，避免不必要的性能开销；乱序时，先找到最长递增子序列作为参考，然后再移动。

(3) Map , 一种新的数据结构，常用方法，遍历，应用场景，WeakMap;

(4) 算法题01：反转字符串中的单词 III ，给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

```text
输入:"Let's take LeetCode contest"
输出:"s'teL ekat edoCteeL tsetnoc"
```

> 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有额外的空格。

```js
方法1：
export default (str)=>{
    //字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    let arr = str.split(' ');
    //对数组进行遍历，然后每个元素进行反转
    let result = arr.map( item => { return item.split('').reverse().join('')} ) 
    return result.join(' ');
}
方法2：split
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.split(' ').map( item => { 
        return item.split('').reverse().join('')} )
        .join(' ');
}
方法3：split + 正则
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.split(/\s/g).map( item => { 
        return item.split('').reverse().join('')} )
        .join(' ');
}
方法4:正则 match
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.match(/[\w']+/g).map( item => { 
        return item.match(/[\w']+/g).reverse().join('')} )
        .join(' ');
}
```

算法的本质是寻找规律并实现。如何找到算法？发现输入和输出的关系，寻找突破点。复杂的实现怎么办？实现是程序+数据结构的结合体。

#### 2020年11月10日 周二  第46周 

(1) Vue3  Composition API 的好处： 逻辑代码更少，更集中，更易扩展；更加丰富的 API 集成；对于 TS 来说，非常友好（利于类型推导）。

(2) setup 选项中没有  this,  无法访问组件声明中的属性；setup 函数接收两个参数 props 与 context; props 不可解构，context 有 attrs 、slots、emit 属性。

#### 2020年11月11日 周三  第46周 

(1) reactive "深"转换响应式副本， readonly 创建只读对象；ref 会添加一个 value 属性，ref.value = newValue; isProxy / isReactive / isReadonly & toRow / toRef / toRefs , is 开头是做判断，返回值是布尔值，to 开头的是做转换作用。

(2) Vue3 生命周期函数的变化：destroy 变成了 unmounted , beforeDetroy 变成了 beforeUnmount; 首先执行的生命周期方法是 setup() , 然后会执行 beforeCreate() 方法, created()方法 , 接着会执行 setup() 方法中的 onBeforeMount()方法 , beforeMount()方法 , 最后执行 onMounted() 方法。

(3)正则表达式修饰符：ES5中有 i - 忽略大小写，m - 多行匹配， g - 全局匹配；ES6 中 y- 粘连修饰符，u - unicode 修饰符。

#### 2020年11月12日 周四  第46周

今天什么也没做呢...

#### 2020年11月13日 周五  第46周

(1) ES6: Proxy 代理，常用拦截方法, new Proxy() , 有两个参数，第一个参数是要代理的对象或数组，第二个参数是代理的钩子对象，里面可以写代理的方法

```js
let obj = {};
let p = new Proxy(obj,{})
p.name = "jerry"
console.log(obj.name) 
Output:"jerry"
```

(2) Vue3 中 Vue-router 变化：引用方式变化，routes 属性加入强判断；不再给路径默认添加 / , redirect 重定向需要写全路径； 动态路由匹配针对(*) 需要使用 pathMatch 属性。

(3) Vue3 中 Redux 变化：Store 的挂载方式发生了变化

```js
import store from './store'
createApp(App).use(store).mount('#app')
```

#### 2020年11月14日 周六  第46周

(1) Vite：Vue 3 专用的独立打包工具，速度非常快。`npm init vite-app <project-name>`; vite 支持热更新 + 冷启动（没有编译的过程）；vite 提供打包构建命令，按需进行打包。

Getting Started:

```shell
npm init vite-app <project-name>
cd <project-name>
npm install
npm run dev
```

(2) Vite 配置 TS 支持，CSS 预编译，路径别名 Alias；整合typescript:配置 tsconfig.json ; 添加 css 预编译：npm install -D sass ; Vue-Router & Vuex, 路径别名的配置方法，图片路径暂不支持。Vite 目前不建议在大项目中尝试应用。

#### 2020年11月15日 周日  第46周

(1)  typescript 中对于有多种类型的数据，建议写 any 类型； 

Validate() 的用法：

```html
<Form v-slot="{validate}" :validation-schema="schema">
    <Field name="email" as="input" />
    <Field name="name" as="input" type="email" />
    <Field name="password" as="input"  type="password"  />
    <Field name="button" as="input" @click="validate">Submit</Field>
</Form>
```

#### 2020年11月16日  周一  第47周

(1) 路由懒加载：const Reg = () => import('@/views/Reg.vue');

(2) Vue filter 过滤器的使用；从路由 -> 入口文件 -> 结构 -> 逻辑；mixin, filter 被遗弃的用法改造；熟练使用组合式 API, 但同时兼顾使用 Options API;

(3) Iterator 是一种接口机制，为各种不同的数据结构提供统一访问的机制，主要供 for ... of 消费，不支持遍历的数据结构“可遍历”。

```js
// 构造一个 iterator 对象
function makeIterator(arr) {
    let nextIndex = 0
    return {
        next() {
            return nextIndex < arr.length ? {
                value:arr[nextIndex++],
                done:false
            }:{
                value:undefined,
                done:true
            }
        }
    }
}
let it = makeIterator(['a','b','c']);
console.log(it.next()) // {value:'a',done:false}
console.log(it.next()) // {value:'b',done:false}
console.log(it.next()) // {value:'c,done:false}
console.log(it.next()) // {value:undefined,done:true}
```

原生具备 Iterator 接口的数据结构：Array , Map , Set , String , TypedArray , 函数的 arguments 对象，NodeList 对象。

#### 2020年11月17日  周二  第47周

(1) ES7 数组扩展：Array.prototype.includes(searchElement, fromIndex) ; includes VS indexOf

includes 属于数组实例的方法，用于检查数组中是否包含某个值，可以使用array.includes()；

includes 和 indexOf 都只能判断基本数据类型的值是否包含在数组中，无法判断引用类型的值；同时在判断是否包含时，includes 和 indexOf 都是严格判断是否相等，等价于 ===； includes 不能检测 NaN 是否存在，arr.includes(NaN) 永远为 true, 但 indexOf 能够检测 NaN 是否存在；

(2) ES7 数值扩展：幂运算符 `**`  等同于 Math.pow()

#### 2020年11月18日  周三  第47周

(1)  React 源码学习： react-element ,  Comp.defaultProps = {value:1} , 在组件中就可以通过 this.props.defaultProps.value 拿到默认值；

```js
const ReactElement = function(type,key,ref,self,source,...)
```

Component & PureComponent : 在 React 中不仅仅只有Component 一种 BaseComponent ，还有 PureComponent , 其中PureComponent 提供了 shouldComponentDidUpdate 实现，减少在 props 不发生变化的情况下，减少组件的更新。

(2)  JS 数据结构及算法：

696 - 计数二进制子串 ， 给定一个字符串 s , 计算具有相同数量 0 和 1 的非空(连续)子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是组合在一起的。重复出现的子串要计算它们出现的次数。

示例1：

```reStructuredText
输入：“00110011”
输出：6
解释：有6个子串具有相同数量的连续1 和 0 ： “0011”，“01”，“1100”，“0011”，“10”
另外，“00110011” 不是有效的子串，因为所有的 0（和1）没有组合在一起
```

> 难度大的算法题目如何解？ 算法的本质是寻找规律并实现；如何找到规律？ 发现输入和输出的关系，寻找突破点； 复杂的实现怎么办？ 实现是程序 + 数据结构的结合体。