#### 2020年11月09日  周一  第46周

(1) Vue3 框架体积，核心代码 + Composition API : 13.5kb , 最小 11.75 kb, 所有 Runtime : 22.5 kb (Vue2 是32kb) 。Vue3 新的特性：TS重写Diff算法，使用Proxy性能更优，框架体积更小；新的Compiler,通过注释标记提升框架性能；Compisition API, 模块化功能代码，摒弃 this; 更好的按需加载（得益于 Tree Shaking）；新增：Fragment、Teleport、Suspence；Vite 开发工具。

(2) 新Diff 算法：patchChildren 根据是否存在 key 进行真正的 diff; 复用真实的 dom 节点，避免不必要的性能开销；乱序时，先找到最长递增子序列作为参考，然后再移动。

(3) Map , 一种新的数据结构，常用方法，遍历，应用场景，WeakMap;

(4) 算法题01：反转字符串中的单词 III ，给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

```text
输入:"Let's take LeetCode contest"
输出:"s'teL ekat edoCteeL tsetnoc"
```

> 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有额外的空格。

```js
方法1：
export default (str)=>{
    //字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    let arr = str.split(' ');
    //对数组进行遍历，然后每个元素进行反转
    let result = arr.map( item => { return item.split('').reverse().join('')} ) 
    return result.join(' ');
}
方法2：split
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.split(' ').map( item => { 
        return item.split('').reverse().join('')} )
        .join(' ');
}
方法3：split + 正则
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.split(/\s/g).map( item => { 
        return item.split('').reverse().join('')} )
        .join(' ');
}
方法4:正则 match
export default (str)=>{
    //1.字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序
    //2.对数组进行遍历，然后每个元素进行反转
    return str.match(/[\w']+/g).map( item => { 
        return item.match(/[\w']+/g).reverse().join('')} )
        .join(' ');
}
```

算法的本质是寻找规律并实现。如何找到算法？发现输入和输出的关系，寻找突破点。复杂的实现怎么办？实现是程序+数据结构的结合体。

#### 2020年11月10日 周二  第46周 

(1) Vue3  Composition API 的好处： 逻辑代码更少，更集中，更易扩展；更加丰富的 API 集成；对于 TS 来说，非常友好（利于类型推导）。

(2) setup 选项中没有  this,  无法访问组件声明中的属性；setup 函数接收两个参数 props 与 context; props 不可解构，context 有 attrs 、slots、emit 属性。

#### 2020年11月11日 周三  第46周 

(1) reactive "深"转换响应式副本， readonly 创建只读对象；ref 会添加一个 value 属性，ref.value = newValue; isProxy / isReactive / isReadonly & toRow / toRef / toRefs , is 开头是做判断，返回值是布尔值，to 开头的是做转换作用。

(2) Vue3 生命周期函数的变化：destroy 变成了 unmounted , beforeDetroy 变成了 beforeUnmount; 首先执行的生命周期方法是 setup() , 然后会执行 beforeCreate() 方法, created()方法 , 接着会执行 setup() 方法中的 onBeforeMount()方法 , beforeMount()方法 , 最后执行 onMounted() 方法。

(3)正则表达式修饰符：ES5中有 i - 忽略大小写，m - 多行匹配， g - 全局匹配；ES6 中 y- 粘连修饰符，u - unicode 修饰符。

#### 2020年11月12日 周四  第46周

今天什么也没做呢...

#### 2020年11月13日 周五  第46周

(1) ES6: Proxy 代理，常用拦截方法, new Proxy() , 有两个参数，第一个参数是要代理的对象或数组，第二个参数是代理的钩子对象，里面可以写代理的方法

```js
let obj = {};
let p = new Proxy(obj,{})
p.name = "jerry"
console.log(obj.name) 
Output:"jerry"
```

(2) Vue3 中 Vue-router 变化：引用方式变化，routes 属性加入强判断；不再给路径默认添加 / , redirect 重定向需要写全路径； 动态路由匹配针对(*) 需要使用 pathMatch 属性。

(3) Vue3 中 Redux 变化：Store 的挂载方式发生了变化

```js
import store from './store'
createApp(App).use(store).mount('#app')
```

#### 2020年11月14日 周六  第46周

(1) Vite：Vue 3 专用的独立打包工具，速度非常快。`npm init vite-app <project-name>`; vite 支持热更新 + 冷启动（没有编译的过程）；vite 提供打包构建命令，按需进行打包。

Getting Started:

```shell
npm init vite-app <project-name>
cd <project-name>
npm install
npm run dev
```

(2) Vite 配置 TS 支持，CSS 预编译，路径别名 Alias；整合typescript:配置 tsconfig.json ; 添加 css 预编译：npm install -D sass ; Vue-Router & Vuex, 路径别名的配置方法，图片路径暂不支持。Vite 目前不建议在大项目中尝试应用。

#### 2020年11月15日 周日  第46周

(1)  typescript 中对于有多种类型的数据，建议写 any 类型； 

Validate() 的用法：

```html
<Form v-slot="{validate}" :validation-schema="schema">
    <Field name="email" as="input" />
    <Field name="name" as="input" type="email" />
    <Field name="password" as="input"  type="password"  />
    <Field name="button" as="input" @click="validate">Submit</Field>
</Form>
```

#### 2020年11月16日  周一  第47周

(1) 路由懒加载：const Reg = () => import('@/views/Reg.vue');

(2) Vue filter 过滤器的使用；从路由 -> 入口文件 -> 结构 -> 逻辑；mixin, filter 被遗弃的用法改造；熟练使用组合式 API, 但同时兼顾使用 Options API;

(3) Iterator 是一种接口机制，为各种不同的数据结构提供统一访问的机制，主要供 for ... of 消费，不支持遍历的数据结构“可遍历”。

```js
// 构造一个 iterator 对象
function makeIterator(arr) {
    let nextIndex = 0
    return {
        next() {
            return nextIndex < arr.length ? {
                value:arr[nextIndex++],
                done:false
            }:{
                value:undefined,
                done:true
            }
        }
    }
}
let it = makeIterator(['a','b','c']);
console.log(it.next()) // {value:'a',done:false}
console.log(it.next()) // {value:'b',done:false}
console.log(it.next()) // {value:'c,done:false}
console.log(it.next()) // {value:undefined,done:true}
```

原生具备 Iterator 接口的数据结构：Array , Map , Set , String , TypedArray , 函数的 arguments 对象，NodeList 对象。

#### 2020年11月17日  周二  第47周

(1) ES7 数组扩展：Array.prototype.includes(searchElement, fromIndex) ; includes VS indexOf

includes 属于数组实例的方法，用于检查数组中是否包含某个值，可以使用array.includes()；

includes 和 indexOf 都只能判断基本数据类型的值是否包含在数组中，无法判断引用类型的值；同时在判断是否包含时，includes 和 indexOf 都是严格判断是否相等，等价于 ===； includes 不能检测 NaN 是否存在，arr.includes(NaN) 永远为 true, 但 indexOf 能够检测 NaN 是否存在；

(2) ES7 数值扩展：幂运算符 `**`  等同于 Math.pow()

#### 2020年11月18日  周三  第47周

(1)  React 源码学习： react-element ,  Comp.defaultProps = {value:1} , 在组件中就可以通过 this.props.defaultProps.value 拿到默认值；

```js
const ReactElement = function(type,key,ref,self,source,...)
```

Component & PureComponent : 在 React 中不仅仅只有Component 一种 BaseComponent ，还有 PureComponent , 其中PureComponent 提供了 shouldComponentDidUpdate 实现，减少在 props 不发生变化的情况下，减少组件的更新。

(2)  JS 数据结构及算法：

696 - 计数二进制子串 ， 给定一个字符串 s , 计算具有相同数量 0 和 1 的非空(连续)子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是组合在一起的。重复出现的子串要计算它们出现的次数。

示例1：

```reStructuredText
输入：“00110011”
输出：6
解释：有6个子串具有相同数量的连续1 和 0 ： “0011”，“01”，“1100”，“0011”，“10”
另外，“00110011” 不是有效的子串，因为所有的 0（和1）没有组合在一起
```

> 难度大的算法题目如何解？ 算法的本质是寻找规律并实现；如何找到规律？ 发现输入和输出的关系，寻找突破点； 复杂的实现怎么办？ 实现是程序 + 数据结构的结合体。

#### 2020年11月19日  周四  第47周

(1) React 源码深度学习：createRef & ref , 用于获取子节点的实例， ref 有三种使用方式，分别是 string ref(不推荐，会被废弃) / function / createRef (React 官方提供的API) 。

```jsx
constructor () {
    super()
    this.objRef = React.createRef()
    // {current:null}
}
componentDidMount() {
    setTimeOut(() => {
      this.refs.stringRef.textContent = "string ref got";
      this.methodRef.textConteng = "method ref got";
      this.objRef.curent.textContent = "obj ref got"  ;
    },1000)
}
render() {
    return (
    	<p ref="stringRef">span1</p>
        <p ref={ele => (this.methodRef = ele)}>spa3</p>
        <p ref={objRef}>spa3</p>
    )
}
```

(2 React 源码深度学习：forwardRef , 可以拿到子组件为 pureComponent 的ref。

```jsx
import Reat from 'react';
const TargetComponent = React.forwardRef((props,ref) => {
    <input type="text" ref={ref} />
})
export default class Comp extends React.Component {
    constructor() {
        super()
        this.ref = React.createRef()
    }
    componentDidMount() {
        this.ref.current.value = "ref got input"
    }
    render() {
        return <TargetComponent ref={this.ref} />
    }
}
```

(3) ES8 （ES2017）学习：async / await  , 是 generator 构造器函数的语法糖，function* foo() { ... yield} , async 表示异步, 相当于 *，写在 function 的前面 ;  await 表示等待， 相当于 yield ; async 会自动返回一个 Promise 对象，相当于 Promise.resolve('demo') ；await 后面通常情况下，会跟一个异步的操作, 等待异步操作完成后，再进行其他的操作；

```js
function timeout() {
    return new Promise(resolve => {
        setTimeout(() => {
            // console.log(1)
            resolve(1)
        },1000)
    })
}
async function () {
    // await timeout()
    let res = await timeout()
    console.log(res)
    console.log(2)
}
foo() // 1,2
```

#### 2020年11月20日  周五  第47周

(1) 数据结构与算法：计算子串

String.prototype.slice;String.prototype.match;String.prototype.repeat;Array.prototype.push;RegExp;

数组在 js 中既可以当队列用(push,pop)，也可以当堆栈用(shift,unshift)；

```js
// 给定一个字符串 s,计算具有相同数量0和1的非空且连续子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的，重复出现的子字符串要计算它们出现的次数。
const subCount = (str) =>{
    // 建立数据结构，数组实现堆栈，保存数据
    let r = []
    // 给定任意子输入都返回第一个符合条件的子字符串
    let match = (str) => {
        // j 为连续的 0 或 1
        let j = str.match(/^(0+|1+)/)[0];
        // 通过 ^ 1 对 j 进行取反操作，并获取 j 后面的值，并保持位数和 j 一致
        let k = (j[0] ^ 1).toSring().repeat(j.length);
        // 匹配包含变量 j,k 的项，即为符合条件的子串
        let reg = new RegExp(`^(${j}${k})`);
        if(reg.test(str)) {
            // 匹配成功，则返回第一个符合条件的值RegExp.$1
            return RegExp.$1
        } else {
            return ''
        }
    }
    // 通过 for 循环控制程序运行流程
    for (var i=0,len=str.length-1;i<len;i++) {
        // 自定义的 match 方法匹配第一个符合条件的子串
        // str.slice(i) 截取当前索引之后的字符串
        let sub = match(str.slice(i));
        if(sub) {
            r.push(sub)
        }
    }
    return r;
}
```

(2) 数据结构与算法：数组 - 电话号码的分组(公式运算)、卡牌分组(归类运算)、种花问题(筛选运算)、格雷编码(二进制运算)

#### 2020年11月21日  周六  第47周

(1)  ES6-ES11: 对象的扩展，Object.values() , Object.entries() , 参数既可以是对象，又可以是数组；Object.entries() ， 返回值是一个二维数组，数组中包含 key 值 和 value 值

```js
let obj = {
    name:'jerry',
    web:"www.jerrychane.com",
    course:'es'
}
for (let [ke,val] of Object.entries(obj)) {
    console.log(`${key}:${val}`)
}
Output:
name:jerry
web:www.jerrychane.com
course:es
```

(2) React 源码深度学习之 Context :  父级组件提供一个 Context 后，只要是在它的子集及以下的组件，都能够访问到 Context 信息，以此达到跨越多级传递数据的作用。

Context 有两种实现方式：一种是通过老版本的 childContextType 方式(React 17 废弃), 一种是通过React 16 以后提供的 createContext 方式。

```js
// 老版本
getChildContext() {
    return {value:this.state.childContext,a:'aaaa'}    
}
// 声明父组件的 childContextTypes
Parent.childContextTypes = {
    value:PropTypes.string
}
// 声明子组件的 contextTypes
Child2.contextTypes = {
    value:PropTypes.string
}
```

```jsx
// React 16 以后
const {Provider,Consumer} = React.createContext('default')
// Provider - 组件提供方，Consumer - 组件订阅方
class Parent extents React.Component {
    ...
    return (
    ...
        <Provider value={this.state.newContext}>{this.props.children}</Provider>
    )
}
// 子组件中使用 newContext
class Child2 extents React.Component {
    ...
    return (
    ...
        <Consumer>{value => <p> newContext:{value}</p>}</Consumer>
    )
}
```

(3 React 源码深度学习之 ConcurrentMode:  它的作用是让 React 的整体渲染过程能够有优先级的高低排列，并且能够使整体的渲染过程中断，从而进行任务的调度。

#### 2020年11月22日  周日  第47周

(1) ES6-ES11: 对象属性描述符，Object.getOwnPropertyDescriptors() 

* value - 当前对象属性的默认值
* writable - 对象属性是否可以修改
* configurable - 能否通过 delete 进行属性删除 ， false 不能删除， true 能够删除
* enumerable - 当前对象是否可以通过 for ... in 形式进行遍历循环

(2) React 源码深度学习之 Suspense, 实现异步组件的加载，不建议正式环境去使用。

(3) React 源码深度学习之 Hooks

(4) 数据结构与算法:电话号码组合, 给定一个仅包含数字 2-9 的字符串，返回所有它能够表示的字母组合。给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。

> 示例：

``` reStructuredText
输入：“23”
输出：["ad", "ae", "af", "bd","be","bf","cd","ce","cf"]
```

> 说明：尽管上面的答案是按字典序排列的，但是你可以任意选择输出的顺序。

```js
export default (str) => {
    // 建立电话号码键盘映射
    let map = ["",1,'abc','def','ghi','jkl','mno','pqrs','tuv','wxyz']
    // 把输入字符串按单字符分隔成数组，234 => [2,3,4]
    let num = str.split('')
    // 保存键盘映射后的字母内容，如 23 => ['abc','def']
    let code = []
    num.forEach(item => {
        if(map[item]) {
            code.push(map[item])
        }
    })
    let comb = (arr) => {
        // 临时变量用来保存前两个组合的结果
        let tmp = []
        // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素
        for(let i = 0, il = arr[0].length; i < il; i++) {
            for(let j = 0, jl = arr[1].length; j < jl; j++) {
                tmp.push(`${arr[0][i]}${arr[1][j]}`)
            }
        }
        arr.splice(0,2,tmp)
        if (arr.length > 2) {
            comb(arr)
        } else {
           return tmp 
        }
        return arr[0]
    }
    return comb(code)
}
```

#### 2020年11月23日  周一  第48周

(1) ES6-ES11:字符串扩展 

- String.prototype.padStart(len, str) ,  在开始的位置填充目标长度(len)的字符串(str), 第2个参数可选，没有第2个参数时，默认是以空格填充;
- String.prototype.padEnd(len, str)) ,  在结束的位置填充目标长度(len)的字符串(str)，第2个参数可选，没有第2个参数时，默认是以空格填充;

#### 2020年11月24日  周二  第48周

(1) React 源码深度学习之 Children,  React Children 有 5个属性和方法:

- map : children 无论是几层，最终都会返回一个展开的数组（一维数组）节点；
- forEach : 没有返回值；
- count
- toArray ： 类似于 map， 只需要 child => child, 也会展开数组，但没有 function 的调用；
- only ： 判断 child 是否是单个的 child ; 

(2) React 源码深度学习之 memo / Fragment /  StrictMode /  cloneElement

(3) ES6-ES11: ES8 中允许函数参数列表使用尾逗号；ES9 异步迭代，for await of , Symbol.asyncIterator

#### 2020年11月25日  周三  第48周

(1) 数据结构与算法：电话号码组合代码篇, Array.prototype.splice。

(2) 数据结构与算法：卡牌分组 - 原理讲解，给定一副牌，每张牌上都写着一个整数。此时，你需要选定一个数字 `X` ,使我们可以将整副牌按下述规则分成1组或更多组。

-  每张牌都有 `X` 张牌。
- 组内所有的牌上都写着相同的整数。( => 排序)

仅当你可选的 `X >= 2` 时返回 `true`

示例1：

```html
输入：[1,2,3,4,4,3,2,1]
输出: true
解释：可行的分组是 [1,1],[2,2],[3,3],[4,4]
```

示例2：

```html
输入: [1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组
```

示例3：

```html
输入:[1]
输出: false
解释: 没有满足要求的分组。
```

示例4：

```html
输入: [1,1]
输出：true
解释：可行的分组是 [1,1]
```

示例5：

```html
输入:[1,1,2,2,2,2]
输出：true
解释：可行的分组是 [1,1],[2,2],[2,2]
```

规律：首先要排序，然后寻找最大公约数，同时公约数要大于1。

演变：如何计算两个数（a,b）的公约数;

a = c * b + d ，a 和 b 如果是整数倍关系，那么 b 就是最大公约数（c>1）。

整数倍关系又分为：

- d = 0 , a = c  *  b
- d > 0,  a = c  *  b + d ,  b = e  * d + f ( 求 b 和 d 的公约数，依次递归  e = 0 || e >0 )

#### 2020年11月26日  周四  第48周

(1) ES6-ES11: ES9 正则表达式扩展

- dotAll ： . 用来匹配任意单个字符，但不能用于匹配多字节的 unicode,也不能匹配行终结符 \n \r ; var reg = /./s , 开启 dotAll ，可以匹配任意单字节 unicode 和 行终结符。
- 具名组匹配 

```js
const reg = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/
console.log(reg.exec('2020-02-01'))
Output:
[
    "2020-02-01",
    "2020",
    "02",
    "01",
    index:0,
    input:"2020-02-01",
    groups:{
        year:"2020",
        month:"02",
        day:"01"
    }
]
// 获取 year, month, day
const groups = reg.exec('2020-02-01').groups
const { year, month, day} = groups
```

- 后行断言

```js
// 先行断言
const str = "ecmscript";
console.log(str.match(/ecma(?=script)/));
// 后行断言 - 匹配,后面必须是 script, 前面必须是 ecma
console.log(str.match(/(?<=ecma)script/));
// 后行断言 - 不匹配,后面必须是 script, 前面必须不是 ecma
console.log(str.match(/(?!ecma)script/));
```

(2)  React 源码深度学习之 ReactDOM.render，React 中创建更新的方式有三种：

- ReactDOM.render || hydrate -  初次渲染

	步骤：创建 ReactRoot -> 创建 FiberRoot 和 RootFiber -> 创建更新 -> 

- setState - 重新渲染

- forceUpdate 强制渲染

#### 2020年11月27日  周五  第48周

(1) React 源码深度学习之 ReactDOM.render & FiberRoot：

- 整个应用的起点
- 包含应用挂载的目标节点
- 记录整个应用更新过程的各种信息

(2) 数据结构和算法：卡牌分组代码演示

```shell
# 运行测试命令
jest test/array/lesson2.test.js
```

知识点: 认真读题，每一个关键词都可能是突破点。

(3) ES9:对象扩展 Rest & Spread, 当使用 ... 克隆一个对象时，是真正的拷贝对象(深拷贝)，而不是引用。

```js
const obj1 = {
    name:'jerry',
    age:32
}
const obj2 = {
    school:'xxx',
    age:20
}
// 克隆对象
const obj3 = {...obj1}
obj1.age = 18
console.log(obj3) // {name:"jerry",age:32}
// 合并对象,如果属性相同，取后面的属性值
const obj4 = {...obj1,...obj2}
console.log(obj4)
// {name:"jerry",school:"xxx",age:20}
```

(4) ES9: Promise 扩展，Promise.prototype.finally(), 无论成功、失败都会进入 finally() 方法；

```js
new Promise((resolve,reject) => {
    setTimeOut(() =>{
        resolve('success')
        // reject('fail')
    },1000)
}).then(res => {
    console.log(res)
}).catch(err => {
    console.log(err)
}).finally(() => {
    console.log('finally')
})
```

(5) ES9:字符串扩展，放松了模板字符串转义序列的语法限制

#### 2020年11月28日  周六  第48周

(1) 数据结构与算法：数组 - 种花问题

假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛(表示为一个数组包含0和1，其中0表示没有种花，1表示种了花)，和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回 True，不能则返回 False。

示例1：

```html
输入：flowerbed = [1,0,0,0,1],n = 1
输出: True
```

示例2：

```html
输入：flowerbed = [1,0,0,0,1],n = 2
输出：False
```

数学建模是算法最重要的一门基础学科。当算法题给的示例很少，很短时，自己要想办法把示例变得更多，更长。1 - 边界问题；2 - 条件(数学建模)

场景1：

```html
[0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,1]
```

场景2：

```html
[1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,1]
[0,1,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,1]
```

核心逻辑

```js
for (let i = 0, len = arr.length - 1; i < len; i++) {
    if (arr[i] === 0) {
        if (i === 0 && arr[1] === 0) {
            max++
            i += 1
        } else if (arr[i - 1] === 0 && arr[i + 1] === 0) {
            max++
            i += 1
        }
    }
}
```

知识点：问题抽象、数学建模、动态输入

(2) ES10(2019)：

对象扩展：Object.fromEntries()

Object.fromEntries() 与 Object.entries() 互逆。Object.fromEntries() 能够将 map 结构的数据转换为对象。

字符串扩展：

String.prototype.trimStart() - 去掉字符串前面的空格; 

String.prototype.trimEnd() - 去掉字符串后面的空格；

String.prototype.trimLeft() - 去掉字符串前面的空格;

 String.prototype.trimRight() - 去掉字符串后面的空格；

String.prototype.trim() - 去掉字符串前后的空格。

数组扩展：多维数组的扁平化

Array.prototype.flat() - 默认参数是1，表示展开1层的深度；参数是Infinity，表示展开无限次；

Array.prototype.flatMap() 是结合了 数组的map() 和 flat() 。

```js
const arr = [1,2,3,4,5]
const res1 = arr.map(x => [x+1]).flat()
console.log(res1) // [2,3,4,5,6]
const res2 = arr.flatMap(x => [x+1])
console.log(res2) // [2,3,4,5,6]
```

(3) React 源码深度学习之 update & UpdateQueue 

用来记录组件状态的改变的一个对象，存放于 UpdateQueue 中，多个 Update 可以同时存在。

(4) React 源码深度学习之 expirationTime

#### 2020年11月29日  周日  第48周

(1) 数据结构与算法之格雷编码：格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。给定一个代码编码总位数的非负整数 n,打印其格雷编码序列。格雷编码序列必须以 0 开头。

示例1：

```html
输入：2
输出：[0,1,3,2]
解释：
00 - 0
01 - 1
11 - 3
10 - 2
对于给定的 n,其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。
00 - 0
10 - 2
11 - 3
01 - 1
```

示例2：

```html
输入：0
输出：[0]
解释：我们定义格雷编码序列必须以 0 开头。给定编码总位数为 n 的格雷编码序列，其长度为2的 n 次方。当 n = 0 时，长度为2的0次方，等于1。
因此，当 n = 0 时，其格雷编码序列为 [0]。
```

(2) React 源码深度解析：different -expirtation-time, 分为 Sync 模式，异步模式，指定 context。

React 源码深度解析：react-setState-forceUpdate

- 给节点的 Fiber 创建更新
- 更新的类型不同

(3) ES10 - Symbol 扩展：Symbol.prototype.description（只读属性）

```js
// Symbol
const s = Symbol('jerry')
console.log(s) // Symbol(jerry)
console.log(s.description) // jerry
const s1 = Symbol('jerry')
console.log(s1) // Symbol()
console.log(s1.description) // undefined
```

(4) ES11- 字符串扩展 - 全局模式捕获：String.prototype.matchAll()

#### 2020年11月30日 周一  第49周

(1) 数据结构与算法：格雷编码-代码演示

| 输入：1 | 输入：2 | 输入：3 |
| ------- | ------- | ------- |
| 输出    | 输出    | 输出    |
| 0       | 00      | 000     |
| 1       | 01      | 001     |
|         | 11      | 011     |
|         | 10      | 010     |
|         |         | 110     |
|         |         | 111     |
|         |         | 101     |
|         |         | 100     |

数组

```js
let make = (n) => {
    if (n===1) {
       return ["0","1"]
    }  else {
        let prev = make(n-1)
        let result = []
        let max = Math.pow(2,n) - 1
        for(let i= 0,len = prev.length -1; i < len; i++) {
            result[i] = `0${prev[i]}`
            result[max-i] = `1${prev[i-1]}` 
        }
        return result
    }
} 
```

(2) React 源码深度解析之Scheduler的整体流程；

(3)  React 源码深度解析之scheduleWork

- 找到更新对应的FiberRoot 节点
- 如果符合条件重置 stack
- 如果符合条件就请求工作调度

(4) ES11-  Dynamic import()  动态导入

```js
const oBtn = document.querySelector('#btn')
oBtn.addEventListener('click',() => {
    import('./ajax').then( mod => {
        // cosole.log(mod)
        mod.default('static/a.json',res => {
            console.log(res)
        })
    })
})
```

(4) ES11- 新的原始数据类型：BigInt

#### 2020年12月01日 周二  第49周

(1) 数据结构与算法：正则表达式 - 重复的子字符串& 正则表达式匹配

重复的子字符串：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过1000。

```html
示例1：
输入:"abab"
输出: true 
解释: 可由子字符串"ab"重复两次构成
示例2:
输入:"aba"
输出: false
示例3:
输入:"abcabcabcabc"
输出: true
解释: 可由子字符串"abc"重复四次构成。（或者子字符串"abcabc" 重复两次构成。）
```

提示：需要使用到正则表达式中的模式匹配  /(foo)(bar)\1\2/，匹配重复的子串需要的正则表达式^(\w+)\1+$

#### 2020年12月02日 周三 第49周

(1) ES11：Promise 扩展

* Promise.allSettled() 
* allSettled() VS all() ：对多个并发任务，无论操作成功还是操作失败，都能得到对应的数据和状态的数组；all() 中对于多个并发，其中只要有一个失败，就会全部失败，得不到成功状态下的数据。

(2) 数据结构与算法：正则表达式匹配，给定一个字符串（s）和一个字符模式（p）。实现支持`.` 和 `*` 的正则表达式匹配。

```html
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```

匹配应该覆盖整个字符串（s）,而不是部分字符串。

说明：

* `s` 可能为空，且只包含从`a-z` 的小写字母。
* `p`可能为空，且只包含从`a-z`的小写字母，以及字符`.` 和`*` 。

示例1：

```html
输入：
s="aa"
p="a"
输出：false
解释："a"无法匹配"aa"整个字符串
```

示例2：

```html
输入:
s="aa"
p="a*"
输出:true
解释:'*' 代表可匹配零个或多个前面的元素，即可以匹配
```

示例3：

```html
输入:
s="ab"
p=".*"
输出:true
解释:'*' 代表可匹配零个或多个('*')任意字符('.')。
```

示例4：

```html
输入:
s="aab"
p="c*a*b"
输出:true
解释:'c'可以不被重复，'a'可以被重复一次。因此可以匹配字符串"aab"。
```

示例5：

```html
输入:
s="mississippi"
p="mis*is*p*."
输出:false
解释:'c'可以不被重复，'a'可以被重复一次。因此可以匹配字符串"aab"。
```

#### 2020年12月03日 周四 第49周

(1) 数据结构与算法：正则表达式匹配-代码演示