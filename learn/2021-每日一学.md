#### 2021年01月08日 周五 第02周

(1)数据结构与算法：队列任务-代码操作

#### 2021年01月11日 周一 第03周

(1) React 源码深度解析： memo 组件的更新 & completeUnitWork的整体流程和意义。

- 根据是否中断调用不同的方法；
- 判断是否有兄弟节点来执行不同的操作；
- 完成节点之后赋值 effect 链；

(2)数据结构与算法：任务队列代码实操

```js
export default (tasks, n) => {
    // 声明一个变量记录最终任务的顺序
    let q = ''
    // 任务分类
    let Q = {}
    tasks.forEach(item => {
        if (Q[item]) {
            Q[item]++
        } else {
            Q[item]=1 
        }
    });
    while (1) {
        let keys = Object.keys(Q)
        if (!keys[0]) {
           break
        } 
        // n+1 为一组
        let tmp = []
        for (let i = 0; i <= n; i++) {
            let max = 0
            let key
            let pos
            // 从所有的任务中找到未处理数最大的优先安排
            keys.forEach((item, idx) => {
                if (Q[item] > max) {
                    max = Q[item]
                    key = item
                    pos = idx
                }
            })
            if (key) {
                tmp.push(key)
                keys.splice(pos, 1)
                Q[key]--
                if (Q[key] < 1) {
                    delete Q[key]
                }
            } else {
                break
            }
        }
        q+=tmp.join('').padEnd(n+1,'-')
    }
    // A--A--A-- 替换为 A--A--A
    q=q.replace(/-+$/g,'')
    return q.length
}
```

(3) 数据结构：排序链表 & 环形链表，重点是：如何手动创建一个链表的数据结构；知道链表如何排序；如何检测链表是闭环的。

排序链表：在O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例1：

```html
输入: 4->2->1->3
输出: 1->2->3->4
```

示例2：

```html
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

快速排序的本质：在遍历时选择一个基准元素，排序中的任何一个元素都可以作为基准元素，通常情况下选第一个就可以。把所有小于基准元素的元素，放在基准元素的左边；大于基准元素的元素，放在基准元素的右边；然后递归左边和右边的所有元素。

链表只会暴露一个头指针，所有的元素是不能直接访问到的，必须通过头指针不断地访问 next 对象，才能拿到具体的元素。设置两个指针p,q，都是指向头元素，p 指针左侧的元素是小于基准元素的，p 与 q 之间的元素是大于基准元素的。

#### 2021年01月12日 周二 第03周

(1) 高仿组件库:

> 参考网站：http://vikingship.xyz

- vikingship 是教学组件库，使用 React Hooks 和 typescript ；
- learning-typescript 为第二章 Typescript 入门源代码，只针对第二章；
- react-with-ts 为课程第三章，神奇的 React 源代码；

#### 2021年01月13日 周三 第03周

(1)数据结构与算法：链表的快速排序比堆排序使用的场景更多。

(2)数据结构与算法：环形链表-原理讲解

环形链表：给定一个链表，判断链表中是否有循环。为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1` ，则在该链表中没有环。

示例1：

```
输入：head = [3,2,0,-4],pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

(3) 环形链表-代码实操

#### 2021年01月14日 周四 第03周

(1) 数据结构与算法：螺旋矩阵 & 旋转图像

给定一个包含 m x n 个元素的矩阵（m行，n列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

示例1：

```
输入：
[
	[1,2,3],
	[4,5,6],
	[7,8,9]
]
输出：[1,2,3,6,9,8,7,4,5]
```

(2) 数据结构与算法：旋转图像

给定一个 n x n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例1：

```
给定 matrix = 
[
	[1,2,3],
	[4,5,6],
	[7,8,9]
]
原地旋转输入矩阵，使其变为：
[
	[7,4,1],
	[8,5,2],
	[9,6,3]
]
```

示例2：

```
给定 matrix = 
[
 [5,1,9,11],
 [2,4,8,10],
 [13,3,6,7],
 [15,14,12,16]
]
原地旋转输入矩阵，使其变为：
[
	[15,13,2,5],
	[14,3,4,1],
	[12,6,8,9],
	[16,7,10,11]
]
```

#### 2021年01月15日 周五 第03周

(1)数据结构与算法：旋转图像-代码实操

```js
export default (arr) => {
  // 获取 n 的维度
  let vecor = arr.length;
  // 垂直翻转
  for (let i = 0, len = vecor / 2; i < len; i++) {
    for (let j = 0, tmp; j < vecor; j++) {
      tmp = arr[i][j];
      arr[i][j] = arr[vecor - i - 1][j];
      arr[vecor - i - 1][j] = tmp;
    }
  }
  // 对角线翻转
  for (let i = 0; i < vecor; i++) {
    for (let j = 0, tmp; j < i; j++) {
      let tmp = arr[i][j];
      arr[i][j] = arr[j][i];
      arr[j][i] = tmp;
    }
  }
  return arr;
};
```

(2)数据结构与算法：对称二叉树-原理讲解，二叉树是出现频率很高，难度最大的数据结构。二叉树的特性之一是一个节点只有两个子节点，左节点和右节点。

给定一个二叉树，检查它是否是镜像对称。例如，二叉树 `[1,2,2,3,4,4,3] ` 是对称的。

```
	    1
	  /	 \
   2 		2
 /  \   / \
3   4  4   3
```

但是下面这个 `[1,2,2,null,3,null,3] ` 则不是镜像对称的：

```
		1
	/		\
	2		2
	\ 	\
	3 	3
```

(3) 数据结构与算法：对称二叉树-代码实操

```js
// 构造二叉树数据结构
// 二叉树的节点
class Node {
  constructor(val) {
    this.val = val;
    this.left = this.right = undefined;
  }
}
// 声明一个二叉树
class Tree {
  constructor(data) {
    // 临时存储所有节点，方便寻找父子节点
    let nodeList = [];
    // 顶节点
    let root;
    for (let i = 0, len = data.length; i < len; i++) {
      let node = new Node(data[i]);
      nodeList.push(node);
      if (i > 0) {
        // 计算当前节点属于哪一层
        let n = Math.floor(Math.sqrt(i + 1));
        // 记录当前层的起始点
        let q = Math.pow(2, n) - 1;
        // 记录上一层的起始点
        let p = Math.pow(2, n - 1) - 1;
        // 找到当前节点的父节点
        let parent = nodeList[p + Math.floor((i - q) / 2)];
        // 将当前节点和上一层的父节点做关联
        if (parent.left) {
          parent.right = node;
        } else {
          parent.left = node;
        }
      }
    }
    root = nodeList.shift();
    nodeList.length = 0;
    return root;
  }
  // 判断是否对称的静态方法
  static isSymmetry(root) {
    if (!root) {
      return true;
    }
    let walk = (left, right) => {
      if (!left && !right) {
        return true;
      }
      if ((left && !right) || (!left && right) || left.val !== right.val) {
        return false;
      }
      return walk(left.left, right.right) && walk(left.right, right.left);
    };
    return walk(root.left, root.right);
  }
}

export default Tree;
export { Node };
```

#### 2021年01月16日 周六 第03周

(1)数据结构与算法：验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

示例1：

```
输入：
 		2
 	/  \
 	1 	3
输出：true
```

(2)数据结构与算法：验证二叉搜索树-代码实操

```js
class Node {
  constructor(val) {
    this.val = val;
    this.left = this.right = undefined;
  }
}

class Tree {
  constructor(data) {
    let root = new Node(data.shift());
    //   遍历所有的数据，逐渐插入到当前这棵搜索树上
    data.forEach((item) => {
      this.insert(root, item);
    });
    return root;
  }
  insert(node, data) {
    if (node.val > data) {
      if (node.left === undefined) {
        node.left = new Node(data);
      } else {
        this.insert(node.left, data);
      }
    } else {
      if (node.right === undefined) {
        node.right = new Node(data);
      } else {
        this.insert(node.right, data);
      }
    }
  }
  static walk(root) {
    if (!root.left && !root.right) {
      return true;
    } else if (
      (root.left && root.val < root.left.val) ||
      (root.right && root.val > root.right.val)
    ) {
      return false;
    } else {
      return Tree.walk(root.left) && Tree.walk(root.right);
    }
  }
}

export default Tree;
export { Node };
```

(3)数据结构与算法：堆排序-原理讲解，根据字符串出现频率排序（排序） & 超级丑数（查找）

堆更靠近二叉树，而非堆栈；应用场景：利用堆的数据结构去排序和查找。

基本概念：

- 堆必须是完全二叉树（n-1层是满二叉树，都有左右节点）；

- 任一节点的值是其子树所有节点的最大值或最小值。

例如：

```
		  	56(最大堆)
			 /   \
		 19     40
    / \     /
   18  9   3
```


```
		  	 5(最小堆)
			 /   \
		 16     30
    / \     /
   49  18  38
```

#### 2021年01月17日 周日 第03周

do nothing.

#### 2021年01月18日 周一 第04周

(1)数据结构与算法：堆排序-代码演示

```js
class Heap {
  constructor(data) {
    this.data = data;
  }
  sort() {
    let iArr = this.data;
    let n = iArr.length;
    if (n <= 1) {
      return iArr;
    } else {
      for (let i = Math.floor(n / 2); i >= 0; i--) {
        Heap.maxHeapify(iArr, i, n);
      }
      for (let j = 0; j < n; j++) {
        Heap.swap(iArr, 0, n - 1 - j);
        Heap.maxHeapify(iArr, 0, n - 1 - j - 1);
      }
      return iArr;
    }
  }
  // 交换两个元素的方法
  static swap(arr, a, b) {
    if (a === b) {
      return "";
    }
    let c = arr[a];
    arr[a] = arr[b];
    arr[b] = c;
  }
  /**
   * 构建最大堆的过程
   * @param {*} Arr 数组
   * @param {*} i  哪个节点
   * @param {*} size 数组有效长度
   */
  static maxHeapify(Arr, i, size) {
    // 左节点（索引）
    let l = i * 2 + 1;
    // 右节点（索引）
    let r = i * 2 + 2;
    let largest = i;
    // 父节点i和左节点l作比较取最大值
    if (l <= size && Arr[l] > Arr[largest]) {
      largest = l;
    }
    // 右节点和最大值比较
    if (r <= size && Arr[r] > Arr[largest]) {
      largest = r;
    }
    if (largest !== i) {
      Heap.swap(Arr, i, largest);
      Heap.maxHeapify(Arr, largest, size);
    }
  }
}

export default Heap;
```

(2)数据结构与算法：堆排序-代码演示

根据字符出现频率排序，给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

示例1：

```
输入："tree"
输出："eert"
解释：'e' 出现两次，'r'和't'都只出现一次。因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。
```

第一步：统计；第二步：排序；第三步：输出；

```js
class Heap {
  constructor(str) {
    let map = new Map();
    str.split("").forEach((item) => {
      if (map.has(item)) {
        map.set(item, map.get(item) + 1);
      } else {
        map.set(item, 1);
      }
    });
    this.map = map;
    this.data = Array.from(map.values());
  }
  sort() {
    let iArr = this.data;
    let n = iArr.length;
    if (n <= 1) {
      return iArr;
    } else {
      for (let i = Math.floor(n / 2); i >= 0; i--) {
        Heap.maxHeapify(iArr, i, n);
      }
      for (let j = 0; j < n; j++) {
        Heap.swap(iArr, 0, n - 1 - j);
        Heap.maxHeapify(iArr, 0, n - 1 - j - 1);
      }
      return iArr;
    }
  }
  toString() {
    let arr = this.sort();
    let str = [];
    while (arr.length) {
      let top = arr.pop();
      for (let [k, v] of this.map) {
        if (v === top) {
          str.push(k.repeat(v));
          this.map.delete(k);
          break;
        }
      }
    }
    return str.join("");
  }
  // 交换两个元素的方法
  static swap(arr, a, b) {
    if (a === b) {
      return "";
    }
    let c = arr[a];
    arr[a] = arr[b];
    arr[b] = c;
  }
  /**
   * 构建最大堆的过程
   * @param {*} Arr 数组
   * @param {*} i  哪个节点
   * @param {*} size 数组有效长度
   */
  static maxHeapify(Arr, i, size) {
    // 左节点（索引）
    let l = i * 2 + 1;
    // 右节点（索引）
    let r = i * 2 + 2;
    let largest = i;
    // 父节点i和左节点l作比较取最大值
    if (l <= size && Arr[l] > Arr[largest]) {
      largest = l;
    }
    // 右节点和最大值比较
    if (r <= size && Arr[r] > Arr[largest]) {
      largest = r;
    }
    if (largest !== i) {
      Heap.swap(Arr, i, largest);
      Heap.maxHeapify(Arr, largest, size);
    }
  }
}

export default Heap;
```

(3)数据结构与算法：超级丑数，丑数，质因数，质数。

编写一段程序来查找第 n 个超级丑数。超级丑数是指其所有质因数都是长度为 k 的质数列表 `primes` 中的正整数。

示例：

```
输入：n=12,primes=[2,7,13,19]
输出：32
解释：给定长度为 4 的质数列表 primes=[2,7,13,19],前12个超级丑数列表为：[1,2,4,7,8,13,14,16,19,26,28,32]。
```

解题思路：

- 求解任意整数的质因数
- 质因数是否在指定质因数范围内
- 是否达到指定个数 n

#### 2021年01月20日 周三 第04周

(1) 数据结构与算法: 超级丑数-代码演示(数组查找)

```js
class Ugly {
  constructor(n, primes) {
    this.n = n;
    this.primes = primes;
  }
  // 计算超级丑数
  getAll() {
    // 超级丑数列表
    let res = [1];
    let i = 2;
    let primes = this.primes;
    while (res.length < this.n) {
      let arr = Ugly.getPrimes(i);
      let k = 0;
      let l = arr.length;
      for (; k < l; k++) {
        if (!primes.find((item) => item === arr[k])) {
          break;
        }
      }
      // k === l 有两种情况，一种就是当前这个数压根没有质因数；一种是所有质因数都在指定列表中
      if (k === l) {
        if (l === 0) {
          if (primes.find((item) => item === i)) {
            res.push(i);
          }
        } else {
          res.push(i);
        }
      }
      i++;
    }
    return res[this.n - 1];
  }
  // 计算指定正整数n的质因数
  static getPrimes(n) {
    //
    let prime = (n) => {
      // 存储所有的质因数
      let arr = [];
      for (let i = 2; i < n / 2 + 1; i++) {
        if (n % i === 0 && !prime(i).length) {
          arr.push(i);
        }
      }
      return arr;
    };
    return prime(n);
  }
}

export default Ugly;
```

(2) 数据结构与算法: 超级丑数-代码演示(堆查找)

```js
class Ugly {
  constructor(n, primes) {
    this.n = n;
    this.primes = new Heap(primes);
  }
  // 计算超级丑数
  getAll() {
    // 超级丑数列表
    let res = [1];
    let i = 2;
    let primes = this.primes;
    while (res.length < this.n) {
      let arr = Ugly.getPrimes(i);
      let k = 0;
      let l = arr.length;
      for (; k < l; k++) {
        if (!primes.find(arr[k])) {
          break;
        }
      }
      // k === l 有两种情况，一种就是当前这个数压根没有质因数；一种是所有质因数都在指定列表中
      if (k === l) {
        if (l === 0) {
          if (primes.find(i)) {
            res.push(i);
          }
        } else {
          res.push(i);
        }
      }
      i++;
    }
    return res[this.n - 1];
  }
  // 计算指定正整数n的质因数
  static getPrimes(n) {
    //
    let prime = (n) => {
      // 存储所有的质因数
      let arr = [];
      for (let i = 2; i < n / 2 + 1; i++) {
        if (n % i === 0 && !prime(i).length) {
          arr.push(i);
        }
      }
      return arr;
    };
    return prime(n);
  }
}

class Heap {
  constructor(arr) {
    this.data = arr;
    this.max = arr.length;
    this.sort();
  }
  find(val, i = 0) {
    let arr = this.data;
    if (val > arr[i] || i > this.max) {
      return false;
    } else if (val === arr[i]) {
      return val;
    } else {
      return this.find(val, i * 2 + 1) || this.find(val, i * 2 + 2);
    }
  }
  sort() {
    let iArr = this.data;
    let n = iArr.length;
    if (n <= 1) {
      return iArr;
    } else {
      for (let i = Math.floor(n / 2); i >= 0; i--) {
        Heap.maxHeapify(iArr, i, n);
      }
      return iArr;
    }
  }
  // 交换两个元素的方法
  static swap(arr, a, b) {
    if (a === b) {
      return "";
    }
    let c = arr[a];
    arr[a] = arr[b];
    arr[b] = c;
  }
  /**
   * 构建最大堆的过程
   * @param {*} Arr 数组
   * @param {*} i  哪个节点
   * @param {*} size 数组有效长度
   */
  static maxHeapify(Arr, i, size) {
    // 左节点（索引）
    let l = i * 2 + 1;
    // 右节点（索引）
    let r = i * 2 + 2;
    let largest = i;
    // 父节点i和左节点l作比较取最大值
    if (l <= size && Arr[l] > Arr[largest]) {
      largest = l;
    }
    // 右节点和最大值比较
    if (r <= size && Arr[r] > Arr[largest]) {
      largest = r;
    }
    if (largest !== i) {
      Heap.swap(Arr, i, largest);
      Heap.maxHeapify(Arr, largest, size);
    }
  }
}
export default Ugly;
export { Heap };
```

(3)进阶算法：贪心算法-买卖股票的最佳时机&柠檬水找零

(4进阶算法: 贪心算法（又称贪婪算法），是指在对**问题求解**时，总是做出在当前看来是最好的的选择。也就是说，不从整理最优上加以考虑，他所做出的是在某种意义上的**局部最优解**。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须是具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

**买卖股票的最佳时机 II:** 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例1：

```
输入：[7,1,5,3,6,4]
输出：7
解释：在第2天（股票价格=1）的时候买入，在第3天（股票价格=5）的时候卖出，这笔交易所能获得利润 = 5-1=4。
随后，在第4天（股票价格=3）的时候买入，在第5天（股票价格=6）的时候卖出，这笔交易所能获得利润 = 6-3=3。
```

示例2：

```
输入：[1,2,3,4,5]
输出：4
解释：在第1天（股票价格=1）的时候买入，在第5天（股票价格=5）的时候卖出，这笔交易所能获得利润 = 5-1=4。
注意你不能在第1天和第2天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例3：

```
输入：[7,6,4,3,1]
输出：0
解释：在这种情况下，没有完成交易，所以最大利润为0。
```

贪心算法：

**问题：最大利润**

**策略1**：从最低点买入，在最高点卖出（追求单次利益）

**策略2**：从低点买入，只要可以赚钱就卖出；不断买卖（追求多次利益，单次利益不够）

**策略3**：从低点买入，到价格高点卖出，不断买卖（在保证单次利益的基础上，实现多次交易）

#### 2021年01月21日 周四 第04周

(1) 数据结构与算法：买卖股票最佳时机-代码实操

```js
export default (prices) => {
  // 用来保存利润
  let count = 0;
  for (let i = 0, len = prices.length; i < len; i++) {
    for (let j = i; j < len - 1; j++) {
      if (prices[j + 1] > prices[j]) {
        count += prices[j + 1] - prices[j];
        i = j;
      } else {
        i = j;
        break;
      }
    }
  }
  return count;
};
```

(2) 数据结构与算法：柠檬水找零-原理讲解，在柠檬水摊位上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你支付5美元、10美元或20美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付5美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true，否则返回 false。

示例1：

```
输入：[5,5,5,10,20]
输出：true
解释：
前3位顾客那里，我们按顺序收取3张5美元的钞票。
第4位顾客那里，我们收取一张10美元的钞票，并返回5美元。
第5位顾客那里，我们找还一张10美元的钞票和一张5美元的钞票。
由于所有客户都得到了正确的找零，所以我们会输出 true。
```

问题：找零钱

策略1：给钱找零，不区分金额直到找到足够的零钱（追求单词找零）

策略2：给钱找零，优先给金额大的零钱，尽量把零钱放在手里（追求多次找零）

示例2：

```
输入：[5,5,10]
输出：true
```

示例3：

```
输入：[10,10]
输出：false
```

示例4：

```
输入：[5,5,10,10,20]
输出：false
```

(3)数据结构与算法：柠檬水找零-代码演示

```js
export default (input) => {
  // 表示自己的钱箱（用于存储零钱）
  let hand = [];
  // 判断是否有顾客还在
  while (input.length) {
    // 取出当前排在最前面顾客的钱
    let money = input.shift();
    // 这种情况不需要找零钱
    if (money === 5) {
      hand.push(money);
    } else {
      // 手里的零钱要降序排列，也就是说最大的面值的钱放在最前面
      hand.sort((a, b) => b - a);
      // 顾客的钱减去饮料的钱就是需要找给顾客的零钱
      let change = money - 5;
      for (let i = 0, len = hand.length; i < len; i++) {
        if (hand[i] <= change) {
          change -= hand[i];
          hand.splice(i, 1);
          // 删除了元素，数组的长度发生了变化，要维持刚才的i不变
          i--;
        }
        if (change === 0) {
          break;
        }
      }
      // 没有足够的钱找给顾客
      if (change !== 0) {
        return false;
      } else {
        // 顾客的钱存起来
        hand.push(money);
      }
    }
  }
  return true;
};
```

#### 2021年01月22日 周五 第04周

(1) 数据结构与算法：进阶算法-动态规划之不同路径II 和 K 站中转内最便宜的航班

动态规划三个重要概念：动态转移方程、最优子结构、边界

不同路径II：一个机器人位于一个 m x n 网格的左上角（起点在下图中标记的 Start）。机器人每次只能向下或向右移动一步。机器人试图到达网格的右下角（在下图中标记为 Finish）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

| Start |      |      |      |      |      |        |
| :---: | ---- | ---- | ---- | ---- | ---- | :----: |
|       |      |      |      |      |      |        |
|       |      |      |      |      |      | Finish |

网格中的障碍物和空位置分别用1和0来表示。

示例1：

```
输入：
[
 [0,0,0],
 [0,1,0],
 [0,0,0]
]
输出：2
解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有2条不同的路径：
1.向右 -> 向右 -> 向下 -> 向下
2.向下 -> 向下 -> 向右 -> 向右
```

mxn：m行n列的状态方程是 F(mxn) = F(m-1xn) + F(mxn-1)

(2)不同路径II-代码实操：

```js
export default (arr, m, n) => {
  let dp = (m, n) => {
    // m=2,n=2 的边界
    if (m === 2 && n === 2) {
      return arr[1][1] || arr[1][0] + arr[0][1] === 2
        ? 0
        : arr[1][0] === 1 || arr[0][1] === 1
        ? 1
        : 2;
    } else if (m < 2 || n < 2) {
      if (m < 2) {
        // 单行有1就返回0，没有1返回1
        return arr[m - 1].includes(1) ? 0 : 1;
      } else {
        // 单列不能有障碍物(1)有它返回0，没有1返回1
        for (let i = 0; i < m; i++) {
          if (arr[i][0] === 1) {
            return 0;
          }
        }
        return 1;
      }
    } else {
      return dp(m - 1, n) + dp(m, n - 1);
    }
  };
  return dp(m, n);
};
```

(3) K站中转内最便宜的航班：有n个城市通过m个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。

现在给定所有的城市和航班，以及出发城市 src 和 目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。

如果没有这样的路线，则输出 -1。

示例1：

```
输入：n=3,edges=[[0,1,100],[1,2,100],[0,2,500]],src=0,dst=2,k=1
输出：200
解释：0 -> 1 -> 2 200; 0 -> 2 500
```

示例2：

```
输入：n=3,edges=[[0,1,100],[1,2,100],[0,2,500]],src=0,dst=2,k=0
输出：500
解释：0 -> 1 -> 2 200; 0 -> 2 500
```

动态转移方程：F(src,dst,k) = Min(F(src,dst-1,k-1) + F(dst-1,dst,1))

(4) k站中转站-代码实操

```js
export default (src, dst, k) => {
  // 对n个城市m个航班做飞行说明
  let fights = [
    [0, 1, 100],
    [1, 2, 100],
    [0, 2, 500],
  ];
  let cheap = (src, dst, k) => {
    // 找到 dst 的前一站
    let prev = fights.filter((item) => item[1] === dst);
    let min = Math.min.apply(
      null,
      prev.map((item) => {
        // 从 dst 往前找，找到了起始城市
        if (item[0] === src && k > -1) {
          return item[2];
        } else if (k === 0 && item[0] !== src) {
          return Number.MAX_SAFE_INTEGER;
        } else {
          return item[2] + cheap(src, item[0], k - 1);
        }
      })
    );
    return min;
  };
  return cheap(src, dst, k) || -1;
};
```

(5) 课程总结：

基础算法：

| 常见类型：字符串、数组、正则 |
| ---------------------------- |
| 常见题型：查重、排序、递归   |
| 知识点：基础API、常用技巧    |

数据结构与算法：

| 常见结构：栈、队列、链表、矩阵、二叉树、堆 |
| ------------------------------------------ |
| 常见题型：结构实现、查找、排序、拓展应用   |
| 知识点：原理、实现、实战思想               |

(6) 前端人的危机如何破解选

选择和被选择都是一种能力。可以选择是一种资本，可以被选择是一种资历，无论是哪种都可以成就一番事业。不然危机会大一些、遗憾也会随之而来。破除危机：积累可以选择的资本 or 增加被选择的资历。

会工作 & 会学习：入门级 - 如何学习？如何面试？如何提升？风险最高。

入门级：

如何学习？人群：学生、转行、自学；目标：学习基础知识；途径：网络博客、视频课程、培训班；方法：临摹；自测：是不是能够独立解决问题；心态：脚踏实地、切莫投机取巧。

如何面试？目标：工作机会；准备：基础知识+实战经验；技巧：基础+能力+潜力；自测：刷题+面经+技术分析。基础知识好不等于要懂所有的知识；每个人都有自己的知识盲区。

如何提升？目标：提升解决问题的能力；方法：多看、多听、多做、多思考，不放过任何一个机会；忌讳：自负、多问题、懒散；自测：是否能独立解决问题。

中高级：如何学习？如何成长？如何晋升？

如何学习？背景：学的很累；原则：先少后多、先精后广；方法：平衡学习、工作、生活的时间，多利用社区的力量；

如何成长？定义：技术、做事；方法：自驱动、敢于挑战、承担责任；自测：技术架构、独立做事、彼此成就。

如何晋升？目标：加薪、晋级；方法：少说、多做、任劳任怨、有效沟通、拒绝平庸、全面发展；心态：先付出再回报、个人服从集体、学会定位和补位、足够耐心。

(7) TS+React打造组件库：

(8) WebRTC学习：

特点：Google开源、跨平台、用于浏览器、实时传输、音视频引擎；

应用领域：音视频会议在线教育、照相机、音乐播放器、共享远程桌面、录制、即时通讯工具、P2P网络加速、文件传输工具、游戏、实时人脸识别；

#### 2021年01月23日 周六 04周

(1) WebRTC学习：学习收获，WebRTC API 的使用；WebRTC 工作原理；信令服务器的设计与搭建；实现1:1实时互动直播系统。

(2) WebRTC 入门与实战：WebRTC 介绍

WebRTC 概述：

- 音视频处理+即时通讯的开源库；
- 2010年 Google 将其开源；
- 它是一个非常优秀的多媒体框架，跨平台；

WebRTC应用：

- 音视频实时互动；游戏、即时通讯、文件传输等等；它是一个百宝箱，传输、音视频处理（回音消除、降噪等）

能学到什么：

- 音视频设备访问与管理；音视频数据的采集；数据的传输与实时互动；WebRTC 的工作机制；

(3) TS+React组件库：安装和初试TypeScript

```bash
# 全局安装
npm install -g typescript@3.7.2
# 查看版本号
tsc -v 
```

（4）TS+React组件库：基础类型， undefined 和 null 是所有类型的子类型

（5）TS+React组件库：any 类型和联合类型，尽可能慎用，

```typescript
//any 类
let notSure: any = 4
notSure = 'maybe it is a string'
notSure = true
notSure.myName
notSure.getName()
```

```typescript
// union 类型
let numberOrString: number | string = 234
numberOrString = 'abc'
```

（6）TS+React组件库：Array 和 Tuple(元组)

```typescript
// Array
let arrayOfNumber: number[] = [1, 2, 3, 4]
arrayOfNumber.push(5)
// Tuple 元组是限定了数据类型的一种数组，必须所有类型都有
let user: [string, number] = ['viking', 1]
```

（7）TS+React组件库：Interface接口，定义对象的类型 

 - 对对象的形状（shape） 进行描述
 - 对类（class） 进行抽象
 - Duck Typing（鸭子类型 ）

```typescript
// interface
interface Person {
    readonly id: number;
    name: string;
    age?: number;
}
let viking: Person = {
    id: 1234,
    name: 'viking',
    age: 20
}
```

可选属性 ？加在属性后面；可读属性，readonly 加在属性前面，readonly 用在对象属性上，而 const  用在变量上；

（8）TS+React组件库：函数和类型判断

```typescript
// 函数声明
function add(x: number, y: number, z?: number): number {
    if (typeof z === 'number') {
        return x + y + z
    } else {
        return x + y
    }
}
let result = add(2, 3, 5)
```

可选参数后不能加确定的参数，否则会报错；也可以添加默认参数。

```typescript
// 函数表达式
function add(x: number, y: number, z: number = 10): number {
    if (typeof z === 'number') {
        return x + y + z
    } else {
        return x + y
    }
}
let result = add(2, 3)
```

```typescript
// 函数表达式,类型推断
const add = function (x: number, y: number, z: number = 10): number {
    if (typeof z === 'number') {
        return x + y + z
    } else {
        return x + y
    }
}
const add2: (x: number, y: number, z?: number) => number = add 
```

typescript 可以在没有明确指定类型时，推断出要使用的类型。

#### 2021年01月24日 周日 04周

(1) WebRTC学习：WebRTC 原理与架构， 网页端和浏览器端。其中浏览器端有包括音频引擎（音频采集和渲染）、视频引擎（视频采集）、传输层（数据的输入输出）。

(2)  WebRTC学习： WebRTC的目录结构

| 编号 | 目录            | 功能                                                   |
| ---- | --------------- | ------------------------------------------------------ |
| 01   | api             | webrtc接口层，浏览器都是通过该接口调用webrtc           |
| 02   | call            | 数据流的管理层，call代表同一个端点的所有数据的流入流出 |
| 03   | video           | 与视频相关的逻辑                                       |
| 04   | audio           | 与音频相关的逻辑                                       |
| 05   | common_audio    | 音频算法相关                                           |
| 06   | common_video    | 视频算法相关                                           |
| 07   | media           | 与多媒体相关的逻辑处理，如编解码的逻辑处理             |
| 08   | logging         | 日志相关                                               |
| 09   | module          | 最重要的目录，子模块                                   |
| 10   | pc              | peer connection,连接相关的逻辑层                       |
| 11   | p2p             | 端对端相关代码，stun，turn                             |
| 12   | rtc_base        | 基础代码，如线程、锁相关的统一接口代码                 |
| 13   | rtc_tool        | 音视频分析相关的工具代码                               |
| 14   | tool_webrtc     | webrtc测试相关的工具代码，如网络模拟器                 |
| 15   | system_warppers | 与具体操作系统相关的代码。如cpu特性，原子操作等        |
| 16   | stats           | 存放各种数据统计相关的类                               |
| 17   | sdk             | 存放android和ios层代码。如视频的采集、渲染等。         |

webrtc modules 目录

| 编号 | 目录                     | 功能                                 |
| ---- | ------------------------ | ------------------------------------ |
| 01   | audio_coding             | 音频编解码相关代码                   |
| 02   | audio_device             | 音频采集与音频播放相关代码           |
| 03   | audio_mixer              | 混音相关代码                         |
| 04   | audio_processing         | 音频前后处理的相关代码               |
| 05   | bitrate_controller       | 码率控制相关的代码                   |
| 06   | congestion_controller    | 流控制相关的代码                     |
| 07   | desktop_capture          | 桌面采集相关的代码                   |
| 08   | pacing                   | 码率探测及平滑处理相关的代码         |
| 09   | remote_bitrate_estimator | 远端码率估算相关的代码               |
| 10   | rtp_rtcp                 | rtp/rtcp协议相关的代码               |
| 11   | video_capture            | 视频采集相关的代码                   |
| 12   | video_coding             | 视频编解码相关的代码                 |
| 13   | video_processing         | 视频前后处理相关的代码，例如人脸识别 |

(4)TS+React组件库：类 Class，第一部分

- 类(Class) :定义了一切事物的抽象特点
- 对象（Object）:类的实例
- 面向对象（OOP）三大特性：封装、继承、多态

```bash
# locally in your project
npm i -D ts-node
npm i -D typescript
# or globally with typescript
npm i -g ts-node
npm i -g typescript

# 在控制台
ts-node class.ts
```

(5)TS+React组件库：类 Class，第二部分，修饰符 public（公共属性） / private（私有属性,子类无法访问） / protected（受保护的属性，子类可以访问该属性）;readonly （只读不可写属性）

 static 表示静态属性或方法，无需实例化即可访问，与实例也无关系。

(6)TS+React组件库：类和接口

```typescript
interface Radio {
    switchRadio(): void;
}
interface Battery {
    checkBatteryStatus();
}
interface RadioWithBattery extends Radio {
    checkBatteryStatus();
}
class Car implements Radio {
    switchRadio() {

    }
}
class Cellphone implements RadioWithBattery {
    switchRadio() {

    }
    checkBatteryStatus() {

    }
}
```

(7)TS+React组件库：枚举（Enum）

```typescript
enum Direction {
    Up = 10,
    Down,
    Left,
    Right,
}
console.log(Direction.Up)
console.log(Direction.Down)
console.log(Direction.Left)
console.log(Direction.Right)
console.log(Direction[10])
```

```typescript
enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    Left = 'LEFT',
    Right = 'RIGHT',
}
const value = 'UP'
if (value === Direction.Up) {
    console.log('go up!')
}
```

使用常量枚举可以提升性能。

```typescript
const enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    Left = 'LEFT',
    Right = 'RIGHT',
}
const value = 'UP'
if (value === Direction.Up) {
    console.log('go up!')
}
```

(7)TS+React组件库：泛型，第一部分。泛型是 TS 中最难的部分。

```typescript
function echo<T>(arg: T): T {
    return arg
}
// const str: string = 'str'
const result = echo(123)

function swap<T, U>(tuple: [T, U]): [U, T] {
    return [tuple[1], tuple[0]]
}
// const result2:[number,string]
const result2 = swap(['string', 123]) 
```

泛型就像一个占位符或者是一个变量，在使用的时候，可以把定义好的类型，像参数一样传入，然后它可以原封不变的输出。

#### 2021年01月25日 周一 05周

(1) WebRTC学习：WebRTC运行机制，Track(轨) & MediaStream（流）

WebRTC重要的类：

- MediaStream
- RTCPeerConnection（最重要的类）
- RTCDataChannel（非音视频的类）

(2)TS+React组件库：泛型-约束泛型

```typescript
// 约束泛型-方案一,返回结果只能是数组
function echoWithArr<T>(arg: T[]): T[] {
    console.log(arg.length)
    return arg
}
const arrs = echoWithArr([1, 2, 3])
// 约束泛型-方案二,通过 extends 和 interface 设置约束条件
interface IWithLength {
    length: number;
}
function echoWithLength<T extends IWithLength>(arg: T): T {
    console.log(arg.length)
    return arg
}
const str = echoWithLength('str')
const obj = echoWithLength({ length: 10, width: 10 })
const arr2 = echoWithLength([1, 2, 3])
```

(3)TS+React组件库：泛型-类和接口

```typescript
// 类使用泛型约束
class Queue<T> {
    private data = []
    push(item: T) {
        return this.data.push(item)
    }
    pop(): T {
        return this.data.shift()
    }
}
const queque = new Queue<number>()
queque.push(1)
console.log(queque.pop().toFixed())

const queque2 = new Queue<string>()
queque2.push('str')
console.log(queque2.pop().length)
```

```typescript
// 接口添加泛型
interface KeyPair<T, U> {
    key: T;
    value: U;
}
let kp1: KeyPair<number, string> = { key: 123, value: 'str' }
let kp2: KeyPair<string, number> = { key: 'test', value: 123 }

let arr: number[] = [1, 2, 3]
let arrTwo: Array<number> = [1, 2, 3]

// inerface 描述一个函数的type
interface IPlus<T> {
    (a: T, b: T): T
}
function plus(a: number, b: number): number {
    return a + b;
}
function connect(a: string, b: string) {
    return a + b;
}
const a: IPlus<number> = plus
const b: IPlus<string> = connect
```

(4)TS+React组件库：类型别名和类型断言

类型别名：

```typescript
// type aliases
type PlusType = (x: number, y: number) => number
function sum(x: number, y: number): number {
    return x + y
}
const sum2: PlusType = sum
// 联合类型下的类型别名
type NameResolver = () => string
type NameOrResolver = string | NameResolver
function getName(n: NameOrResolver): string {
    if (typeof n === 'string') {
        return n
    } else {
        return n()
    }
}
```

类型断言：

```typescript
// type assertion
function getLength(input: string | number): number {
    const str = input as String
    if (str.length) {
        return str.length
    } else {
        const number = input as Number
        return number.toString().length
    }
}
// 更简单的写法
// type assertion
function getLength(input: string | number): number {
    if ((<string>input).length) {
        return (<string>input).length
    } else {
        return input.toString().length
    }
}
```

(5)TS+React组件库：声明文件，声明文件通常是d.ts后缀的文件，例如jQquery.d.ts

```bash
npm install --save @types/jquery
```

#### 2021年01月26日 周二 05周

(1) WebRTC学习：Web服务器工作原理

Web服务器选型：

- Nodejs
- Nginx
- Apache

两个V8引擎：Chrome & Node

(2) TS+React打造个人组件库：React 简介和基础知识，props&state，组件的生命周期，状态提升和单向数据流。

(3) TS+React打造个人组件库：配置 React 开发环境

- 官方脚手架工具-create-react-app

```bash
npx create-react-app ts-with-react --template typescript
```

npx 是什么？

- 避免安装全局模块
- 调用项目内部安装的模块

#### 2021年01月27日 周三 05周

(1) WebRTC学习：Nodejs环境搭建

Nodejs 的安装方式：1.二进制库安装；2.源码安装；

二进制库安装步骤：

- apt/brew/yum install nodejs
- apt/brew/yum install npm

```bash
apt-cache search nodejs
apt install nodejs
apt install npm
```

源码安装步骤：

- 下载 Nodejs 源码
- 生成 Makefile
- `make -j 4 && sudo make install`

```bash
wget -c https://npm.taobao.org/mirrors/node/v14.15.4/node-v14.15.4.tar.gz
# 解压
tar -zvxf node-v14.15.4.tar.gz
cd node-v14.15.4
ls configure
./configure --prefix=/usr/local/nodejs
```

（2）TS+React 打造组件库：第一个组件 - ts为组件助力

```typescript
import React from 'react'

interface IHelloProps {
    message?: string;
}
// type React.FC<P = {}> = React.FunctionComponent<P>
const Hello: React.FC<IHelloProps> = (props) => {
    return <h2>{props.message}</h2>
}
Hello.defaultProps = {
    message: 'Hello World'
}
export default Hello
```

（3）TS+React 打造组件库：什么是和为什么要用 React Hook，React 16.8 带来的新特性，即将替代 class 组件的写法

没有破坏性改动：1.完全可选；2.百分百向后兼容；3.没有计划从 React 移除 class;

为什么用 hook：组件很难复用状态逻辑； 复杂组件难以理解，尤其是生命周期函数；React 组件一直是函数，使用 Hook 完全拥抱函数；

（4）TS+React 打造组件库：在函数组件使用 state-useState Hook

Hook 是什么？Hook 是一个函数，它可以钩住 React 组件的特性; 什么时候会使用 useState Hook ? 

```tsx
import React, { useState } from 'react'
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0)
    const [on, setOn] = useState(true)
    return (
        <>
            <button onClick={() => { setLike(like + 1) }}>
                {like + 1} 👍
        </button>
            <button onClick={() => { setOn(!on) }}>
                {on ? 'ON' : 'OFF'} 👍
        </button>
        </>
    )
}
export default LikeButton
```

（5）TS+React 打造组件库：useEffect 第一部分-初出茅庐

- 无需清除的 Effect，例如发送网络请求，手动变更DOM，记录日志；
- 需要清除的 Effect

useEffect 在第一次渲染和每次渲染时都会执行。

代码时间：使用 useEffect 完成 DOM 的更新

```tsx
import React, { useState, useEffect } from 'react'
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0)
    const [on, setOn] = useState(true)
    useEffect(() => {
        document.title = `点击了 ${like} 次`
    })
    return (
        <>
            <button onClick={() => { setLike(like + 1) }}>
                {like + 1} 👍
        </button>
            <button onClick={() => { setOn(!on) }}>
                {on ? 'ON' : 'OFF'} 👍
        </button>
        </>
    )
}
export default LikeButton
```

（6）TS+React 打造组件库：useEffect 第二部分-有始有终

- 需要清除的Effect
- 代码时间：使用 useEffect 完成一个鼠标跟踪器

```typescript
import React, { useState, useEffect } from 'react'

const MouseTracker: React.FC = () => {
    const [postions, setPositions] = useState({ x: 0, y: 0 })
    useEffect(() => {
        console.log('add effect', postions.x)
        const updateMouse = (e: MouseEvent) => {
            console.log('inner')
            setPositions({ x: e.clientX, y: e.clientY })
        }
        document.addEventListener('click', updateMouse)
        return () => {
            console.log('move effect', postions.x)
            document.removeEventListener('click', updateMouse)
        }
    })
    console.log('before render', postions.x)
    return (
        <p>X: {postions.x} ,Y:{postions.y} </p>
    )
}

export default MouseTracker
```

#### 2021年01月28日 周四 05周

(1) WebRTC学习：最简单的 http 服务

- require 引入 http 模块
- 创建 http 服务
- 指定监听端口

```javascript
// 创建 http.js
"use strict";
var http = require("http");
var app = http
  .createServer(function (req, res) {
    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("Hello World\n");
  })
  .listen(8080, "127.0.0.1");
```

```bash
# 运行 http.js 的三种方式
# 方式一，断开服务后，所有服务终止
node http.js
# 方式二，一直保持，但日志输出有问题
nohub node http.js & 
# 方式三，通过 forever,在后台启动或停止程序
forever start http.js
forever stop http.js
```

```bash
npm install forever -g 
```

#### 2021年01月29日 周五 05周

(1) WebRTC学习：创建 https 服务

为什么要使用HTTS服务？ 个人隐私及安全问题；https 是未来的趋势；HTTPS = HTTP + TLS/SSL

Nodejs 搭建 HTTPS 服务？ 生成 HTTPS 证书；引入 HTTPS 模块；指定证书位置，并创建 HTTPS 服务

```javascript
"use strict";
var https = require("https");
var fs = require("fs");
var options = {
  // 证书的地址
  key: fs.readFileSync("./....xxx.key"),
  cert: fs.readFileSync("./....xxx.pem"),
};
var app = https
  .createServer(options, function (req, res) {
    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("HTTPS:Hello World!\n");
  })
  .listen(443, "0,0,0,0");
```

（2）TS+React 打造组件库：useEffect 第三部分-控制运行

```typescript
import React, { useState, useEffect } from 'react'
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0)
    const [on, setOn] = useState(true)
    useEffect(() => {
        console.log('document title effect is runnning')
        document.title = `点击了 ${like} 次`
    }, [like, on])
    return (
        <>
            <button onClick={() => { setLike(like + 1) }}>
                {like + 1} 👍
        </button>
            <button onClick={() => { setOn(!on) }}>
                {on ? 'ON' : 'OFF'} 👍
        </button>
        </>
    )
}
export default LikeButton
```

(3)TS+React 打造组件库：自定义 Hook-重构 MouseTracker，将组件逻辑抽取到可重用的函数中; 自定义 hooks 函数必须使用 `use` 开头

```tsx
import React, { useState, useEffect } from 'react'
const useMousePositon = () => {
    const [positions, setPositions] = useState({ x: 0, y: 0 })
    useEffect(() => {
        console.log('add effect', positions.x)
        const updateMouse = (e: MouseEvent) => {
            setPositions({ x: e.clientX, y: e.clientY })
        }
        document.addEventListener('mousemove', updateMouse)
        return () => {
            console.log('move effect', positions.x)
            document.removeEventListener('mousemove', updateMouse)
        }
    }, [])
    return positions
}
export default useMousePositon
```

(4)TS+React 打造组件库：自定义 Hook 第二部分-HOC的劣势

- 高阶组件就是一个函数，接受一个组件作为参数，返回一个新的组件。

#### 2021年01月31日 周日 05周

(1)WebRTC学习：真正的Web服务器，既支持http又支持https

- 引入express模块
- 引入server-index模块
- 指定发布目录

```bash
npm i express@4.16.4 serve-index@1.9.1 --save
```

(2)TS+React 打造组件库：自定义hook第三部分-正确的方式完成 URLLoader

```typescript
import { useState, useEffect } from 'react'
import axios from 'axios'

const useURLLoader = (url: string, deps: any[] = []) => {
    const [data, setData] = useState<any>(null)
    const [loading, setLoading] = useState(false)
    useEffect(() => {
        setLoading(true)
        axios.get(url).then(result => {
            setData(result.data)
            setLoading(false)
        })
    }, deps)
    return [data, loading]
}
export default useURLLoader
```

 可以将逻辑上重复的代码提取到一个函数中，像调用一个函数一样调用 hooks，使用hooks返回结果，做我们想做的。

(3)TS+React 打造组件库：useRef - state遇到的难题

在任意一次渲染过程中，props 和 state 始终是保持不变的，如果 props 和 state 在渲染过程中是相互独立的，那么使用到它们的任何值，也都是独立的。useRef 是让不同的渲染之间产生联系的 hook 函数。

(4)TS+React 打造组件库：useRef - 多次渲染之间的纽带

修改 ref 的值，组件不会重新渲染；

#### 2021年02月01日 周一 06周

(1)WebRTC学习：JavaScript 调试方法

```javascript
// google demo
https://appr.tc
```

(2)TS+React 打造组件库：useContext-解决多层传递属性的灵丹妙药

context 提供了一种在组件间共享属性的方式，而不必通过组件树的形式，通过每个层级显示的传递 props。context 的设计是为了共享对于组件树而言是全局的数据。

```typescript
// App.tsx
export const ThemeContext = React.createContext(themes.light)
<ThemeContext.Provider value={themes.dark}></ThemeContext.Provider>

// LikeButton.tsx
import React, { useState, useEffect, useRef, useContext } from 'react'
const theme = useContext(ThemeContext)
    console.log(theme)
    const style = {
        background: theme.background,
        color: theme.color
    }
```

#### 2021年02月03日 周三 06周

(1) WebRTC学习：变量与基本运算

基础知识：变量与类型、for循环、基本运算、函数、if/else、日志打印

**变量与类型**

|          | javascript          | C语言                    |
| -------- | ------------------- | ------------------------ |
| 定义变量 | `var a;` ; `let a;` | `int a;`                 |
| 布尔     | `true` or`false`    | `1` or `0`               |
| 字符串   | `'hello world'`     | `char str="hello world"` |
| 数组     | `[1,5.1,'  hw']`    | `Int arr[]= {1,5,6}`     |
| 空       | `null`,`undefined`  | `NULL`,`0`               |

**基本运算**

|          | javascript      | C语言           |
| -------- | --------------- | --------------- |
| 算数运算 | `+, -, *, / ,%` | `+, -, *, / ,%` |
| 比较运算 | `>,<,!=,==,===` | `>,<,!=,==`     |
| 逻辑运算 | `&&,||,!`       | `&&,||,!`       |

#### 2021年02月04日 周四 06周

(1) WebRTC学习：判断循环与函数

|                  | javascript                               | C语言              |
| ---------------- | ---------------------------------------- | ------------------ |
| `if ... else`    | `if (){} else if(){} else{}`             | 同 javascript 一样 |
| `switch ...case` | `switch case`                            | 同 javascript 一样 |
| `for`            | `for(...){}`                             | 同 javascript 一样 |
| `for ...in`      | `for(var i in arr){console.log(arr[i])}` | 无                 |
| `while`          | `while(){}`                              | 同 javascript 一样 |

**函数**

|          | javascript                          | C语言                          |
| -------- | ----------------------------------- | ------------------------------ |
| 函数定义 | `function func(...){...return ret}` | `int func(...){...return ret}` |
| 箭头函数 | `()=>{...}`                         | 无                             |

(2)TS+React 打造组件库：hook 规则和其他 hook

- 只在最顶层使用 hook
- 只在React函数中调用 hook

其他 hook : useReducer,useCallback

(3)TS+React 打造组件库：组件库起航-需求分析

完成一个组件库需要考虑的问题？

- 代码结构

- 样式解决方案

- 组件需求分析和编码

- 组件测试用例分析和编码

- 代码打包输出和发布

- CI/CD，文档生成等等

初始化组件项目

  ```bash
npx create-react-app jerrychaneui --template typescript
  ```

####  2021年02月05日 周五 06周

 (1)TS+React 打造组件库：文件结构和代码规范

一种是按照功能和路由；一种是按照文件类型；尽可能简单，本项目使用的文件结构如下

```
jerrychaneui/
	README.md
	node_modules
	package.json
	tsconfig.json
	src/
		components/
			Button/
				button.tsx
				button.test.tsx
				style.scss
    styles/
    	...
    index.tsx
```

代码规范: 2.0.4 以上的版本，不需要特殊配置，默认支持 `typescript` 语法检查，需安装 `eslint`插件。

(2)TS+React 打造组件库：样式解决方案分析

- Inline CSS(性能最好)

```jsx
const divStyle = {
  color:'blue',
  backgroundImg:'url('+imgUrl+')',
}
function HelloComponent(){
  return <div style={style}>Hello</div>
}
```

- CSS in JS

- Style Component

- Sass / Less(本项目推荐)

样式文件系统结构：

```
styles/
	_variables.scss(各种变量以及可配置设置)
	_mixins.scss(全局 mixins)
	_functions.scss(全局 functions)
components/
	Button/
		style.scss(单组织文件的样式)
		...
```

(3) WebRTC学习：WebRTC获取音视频设备

API: enumerateDevices()

**基本格式**

```javascript
var ePromise = navigator.mediaDevices.enumerateDevices();
```

返回值是一个 Promise

**MediaDevicesInfo**

MediaDevicesInfo 中存放了许多音视频相关的信息；

| 属性     | 说明                                      |
| -------- | ----------------------------------------- |
| deviceID | 设备ID                                    |
| label    | 设备的名字                                |
| kind     | 设备的种类                                |
| groupID  | 两个设备GroupID相同，说明是同一个物理设备 |

**JavaScript 中的 Promise**

(4) WebRTC学习：在页面中显示获取到的设备

```javascript
// js/client.js
"use strict";
var audioSource = document.querySelector("select#audioSource");
var audioOutput = document.querySelector("select#audioOutput");
var videoSource = document.querySelector("select#videoSource");

if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
  console.log("enumerateDevices is not supported!");
} else {
  navigator.mediaDevices.enumerateDevices().then(gotDevice).catch(handleError);
}

function gotDevice(deviceInfos) {
  deviceInfos.forEach((deviceInfo) => {
    var option = document.createElement("option");
    option.text = deviceInfo.label;
    option.value = deviceInfo.deviceId;
    if (deviceInfo.kind === "audioinput") {
      audioSource.appendChild(option);
    } else if (deviceInfo.kind === "audiooutput") {
      audioOutput.appendChild(option);
    } else if (deviceInfo.kind === "videoinput") {
      videoSource.appendChild(option);
    }
  });
}

function handleError(error) {
  console.log(error.name + " : " + error.message);
}
```

#### 2021年02月07日 周日 06周

(1) WebRTC学习：WebRTC 音视频数据采集

基本格式：

```javascript
var promise = navigator.mediaDevices.getUserMedia(constraints)
```

MediaStreamConstrains:

```javascript
dictionary MediaStreamConstraints {
  (boolean or MediaTrackConstraints) video = false;
  (boolean or MediaTrackConstraints) audio = false;
}
```

```javascript
// js/client
"use strict";
var videoplay = document.querySelector("video#player");

function gotMediaStream(stream) {
  videoplay.srcObject = stream;
}

function handleError(error) {
  console.log("getUserMedia error:", error);
}

if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
  console.log("getUserMedia is not supported");
} else {
  var constraints = {
    video: true,
    audeo: true,
  };
  navigator.mediaDevices
    .getUserMedia(constraints)
    .then(gotMediaStream)
    .catch(handleError);
}
```

(2) WebRTC学习：浏览器适配方法 WebRTC_API 适配

getUserMedia 适配：

- W3C 规范中：getUserMedia
- Chrome: webkitGetUserMedia
- Firefox: mozGetUserMedia

自己实现：

```javascript
var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia|| navigator.mozGetUserMedia;
```

使用 Google 开源库 adapter.js,适配不同浏览器的 API

```
https://webrtc.github.io/adapter/adapter-latest.js
```

(3)TS+React 打造组件库：添加自己的色彩体系

创建自己组件库的色彩体系

- 系统色板 - 基础色板 + 中性色板
- 产品色板 - 品牌色 + 功能色板

Bootstrap 的色彩体系

- #0275d8 (蓝色)、#5cb85c(绿色)、#5bc0de(浅蓝)、#f0ad4e(橙色)、#d9534f(红色)、#292b2c(黑色)、#f7f7f7(白色)

我们组件库的色彩体系

- #0d6efd (蓝色)、#6c757d(黑色)、#52c41a(绿色)、#fadb14(橙色)、#dc3545(红色)、#17a2b8(黑色)

```shell
npm i node-sass --save
```

(4)TS+React 打造组件库：添加字体变量解决方案

组件库样式变量分类：1-基础色彩系统；2-字体系统；3-表单；4-按钮；5-边框和阴影；6-可配置开关

#### 2021年02月08日 周一 07周

(1) WebRTC学习：安全管理-获取音视频设备的访问权限

```javascript
"use strict";
var videoplay = document.querySelector("video#player");
let audioSource = document.querySelector("select#audioSource");
let audioOutput = document.querySelector("select#audioOutput");
let videoSource = document.querySelector("select#videoSource");

function gotDevices(deviceInfos) {
  deviceInfos.forEach((deviceInfo) => {
    let option = document.createElement("option");
    option.text = deviceInfo.label;
    option.value = deviceInfo.deviceId;
    if (deviceInfo.kind === "audioinput") {
      audioSource.appendChild(option);
    } else if (deviceInfo.kind === "audiooutput") {
      audioOutput.appendChild(option);
    } else if (deviceInfo.kind === "videoinput") {
      videoSource.appendChild(option);
    }
  });
}

function gotMediaStream(stream) {
  videoplay.srcObject = stream;
  return navigator.mediaDevices.enumerateDevices();
}

function handleError(error) {
  console.log("getUserMedia error:", error);
}

if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
  console.log("getUserMedia is not supported");
} else {
  var constraints = {
    video: true,
    audio: true,
  };
  navigator.mediaDevices
    .getUserMedia(constraints)
    .then(gotMediaStream)
    .then(gotDevices)
    .catch(handleError);
}
```

(2)TS+React 打造组件库：初次亮相-添加normalize.css

```
https://github.com/necolas/normalize.css
```

#### 2021年02月09日 周二 07周

(1) WebRTC学习：视频参数调整-视频约束，WebRTC 音视频采集约束

- width / height / aspectRatio(比例) / frameRate(帧率) 
- facingMode(user:前置摄像头；environment:后置摄像头；left:前置左摄像头；right:前置右摄像头)
- resizeMode:画面是否需要裁剪

#### 2021年02月10日 周三 07周

(1)WebRTC学习：视频参数调整-视频约束，WebRTC 音视频采集约束

```javascript
var constraints = {
    video: {
      width: {
        min:480,
        max:640
      },
      height:  {
        min:240,
        max:320
      },
      frameRate:  {
        min:15,
        max:30
      },
      facingMode: "environment",
    },
    audio: false,
  };
```

(2)WebRTC学习：音频参数调整-音频约束

- volume(音量):0-1.0
- sampleRate(采样率)：48000,32000,8000
- sampleSize(采样大小)：16位即2字节
- echoCancellation(回音)：true || fasle
- autoGainControl(自动增益): true || fasle
- noiseSuppression(降噪): true || fasle
- latency(延迟大小):200ms以内是最好的
- channelCount(单双声道)
- deviceID、groupID

#### 2021年02月12日 周五 07周

do nothing

#### 2021年02月14日 周日 07周

do nothing

#### 2021年02月15日 周一 08周

(1)WebRTC学习：视频特效

- CSS filter,-webkit-filter/filter
- 如何将 video 与 filter 关联
- OpenGL/Metal/ ...

支持的特效类型：

| 特效       | 说明     | 特效        | 说明   |
| ---------- | -------- | ----------- | ------ |
| grayscale  | 灰度     | opacity     | 透明度 |
| sepia      | 褐色     | brightness  | 亮度   |
| saturate   | 饱和度   | contrast    | 对比度 |
| hue-rotate | 色相旋转 | blur        | 模糊   |
| invert     | 反色     | drop-shadow | 阴影   |

#### 2021年02月16日 周二 08周

do nothing

#### 2021年02月17日 周三 08周

(1)TS+React 打造组件库：添加 normalize.css

(2)TS+React 打造组件库：Button 组件需求分析

- 不同的 Button Type: Primary, Default, Danger, Link Button;
- 不同的 Button Size: Normal, Small, Large;
- Disable 的状态：Disabled(普通的不可用), Link Button(链接的不可用);

```jsx
<Button
  size="lg"
  type="primary"
  disabled
  href="" ?
  className="" ?
  autoFocus="" ?
  ...
  >
  JerryChane Button
</Button>
```

(3)WebRTC学习：从视频中获取图片

1、拿到音视频流
2、点击button拿到该帧
3、使用canvas输出成图片

(4)WebRTC学习：只采集音频数据

#### 2021年02月18日 周四 08周

(1) WebRTC学习：MediaStreamAPI及获取视频约束

MediaStreamAPI

- MediaStream.addTrack()
- MediaStream.removeTrack()
- MediaStream.getVedeoTracks()
- MediaStream.getAudioTracks()

MediaStream 事件API

- MediaStream.onaddtrack
- MediaStream.onremovetrack
- MediaStream.onended

(2)TS+React 打造组件库：Button 组件编码第一部分

```bash
npm install classnames --save
npm install @types/classnames --save
```

(3)TS+React 打造组件库：添加 Button 基本样式

#### 2021年02月19日 周五 08周

(1)TS+React 打造组件库：升级 Button 组件样式

```scss
/*_mixin.scss*/
@mixin button-size($padding-y, $padding-x, $font-size, $border-radius) {
    padding: $padding-y $padding-x;
    font-size: $font-size;
    border-radius: $border-radius;
}

@mixin button-style($background,
    $border,
    $color,
    $hover-background:lighten($background, 7.5%),
    $hover-border:lighten($border, 10%),
    $hover-color: $color) {
    color: $color;
    background: $background;
    border-color: $border;

    &:hover {
        color: $hover-color;
        background: $hover-background;
        border-color: $hover-border;
    }

    &:focus,
    &.focus {
        color: $hover-color;
        background: $hover-background;
        border-color: $hover-border;
    }

    &:disabled,
    &.disabled {
        color: $color;
        background: $background;
        border-color: $border;
    }
}
```

(2)TS+React 打造组件库：精益求精 - Buton 组件编码第二部分

```tsx
// 获取按钮上的属性，并合并
type NativeButtonProps = BaseButtonProps & React.ButtonHTMLAttributes<HTMLElement>
// 获取链接上的属性，并合并
type AnchorButtonProps = BaseButtonProps & React.AnchorHTMLAttributes<HTMLElement>
// 合并所有属性，并导出
export type ButtonProps = Partial<NativeButtonProps & AnchorButtonProps>
```

(3)TS+React 打造组件库：为什么要有测试

国内互联网测试现状

- 重视程度严重不足 、 没有时间、不会写测试

测试的重要性

- 高质量的代码、更早的发现 Bug,减少成本、让重构和升级变得更加容易和可靠、让开发流程更加敏捷

测试金字塔

- 从下到上：Unit => Service => UI

React 组件特别适合写单元测试

- Component 组件化、 Function 函数 、单向数据流

#### 2021年02月20日 周六 08周

(1)TS+React 打造组件库：通用测试框架 Jest 出场

creat-react-app 脚手架内置了 jest ，可以使用 `npx jest aaa.js --watch`,来测试

```javascript
test("test common matcher", () => {
  expect(2 + 2).toBe(4);
  expect(2 + 2).not.toBe(5);
});

test("test to be true or false", () => {
  expect(1).toBeTruthy();
  expect(0).toBeFalsy();
});

test("test number", () => {
  expect(4).toBeGreaterThan(3);
  expect(2).toBeLessThan(3);
});
// toBe 表示完全相同，相当于 === toEqual 相当于 ==
test("test object", () => {
  // expect({ name: "jerrychane" }).toBe({ name: "jerrychane" });
  expect({ name: "jerrychane" }).toEqual({ name: "jerrychane" });
});
```

(2)TS+React 打造组件库：React 测试工具 - react-testing-library

```tsx
// jerrychaneui/src/components/Button/button.test.tsx
import React from 'react'
import { render } from '@testing-library/react'
import Button from './button'

test('our first react test case', () => {
    const wrapper = render(<Button>Nice</Button>)
    const element = wrapper.queryByText('Nice')
    expect(element).toBeTruthy()
})
```

运行测试文件： `npm  run test`

(3)TS+React 打造组件库：添加Button 测试代码 第一部分

```tsx
// jerrychaneui/src/components/Button/button.test.tsx
describe('test Button component', () => {
    it('should render the correct  default button', () => {
        const wrapper = render(<Button>Nice</Button>)
        const element = wrapper.getByText('Nice')
        expect(element).toBeInTheDocument()
        expect(element.tagName).toEqual('BUTTON')
        expect(element).toHaveClass('btn btn-default')
    })
    it('should render the correct component based on different props', () => {

    })
    it('should render a link when btnType equals link and href is provided', () => {

    })
    it('should render disabled button when disabled set to true', () => {

    })
})
```

(4)TS+React 打造组件库：添加Button 测试代码 第二部分

```tsx
// jerrychaneui/src/components/Button/button.test.tsx
import React from 'react'
import { render, fireEvent } from '@testing-library/react'
import Button, { ButtonProps, ButtonSize, ButtonType } from './button'

const defaultProps = {
    onClick: jest.fn()
}

const testProps: ButtonProps = {
    btnType: ButtonType.Primary,
    size: ButtonSize.Large,
    className: 'klass'
}
const disabledProps: ButtonProps = {
    disabled: true,
    onClick: jest.fn()
}

describe('test Button component', () => {
    it('should render the correct  default button', () => {
        const wrapper = render(<Button {...defaultProps}>Nice</Button>)
        const element = wrapper.getByText('Nice') as HTMLButtonElement
        expect(element).toBeInTheDocument()
        expect(element.tagName).toEqual('BUTTON')
        expect(element).toHaveClass('btn btn-default')
        expect(element.disabled).toBeFalsy()
        fireEvent.click(element)
        expect(defaultProps.onClick).toBeCalled()
    })
    it('should render the correct component based on different props', () => {
        const wrapper = render(<Button {...testProps}>Nice</Button>)
        const element = wrapper.getByText('Nice')
        expect(element).toBeInTheDocument()
        expect(element).toHaveClass('btn-primary btn-lg klass')
    })
    it('should render a link when btnType equals link and href is provided', () => {
        const wrapper = render(<Button btnType={ButtonType.Link} href="https://jerrychane.com" >Link</Button>)
        const element = wrapper.getByText('Link')
        expect(element).toBeInTheDocument()
        expect(element.tagName).toEqual('A')
        expect(element).toHaveClass('btn btn-link')
    })
    it('should render disabled button when disabled set to true', () => {
        const wrapper = render(<Button {...disabledProps}>Nice</Button>)
        const element = wrapper.getByText('Nice') as HTMLButtonElement
        expect(element).toBeInTheDocument()
        expect(element.disabled).toBeTruthy()
        fireEvent.click(element)
        expect(disabledProps.onClick).not.toHaveBeenCalled()
    })
})
```

#### 2021年02月21日 周日 08周

do nothing

#### 2021年02月22日 周一 09周

(1)TS+React 打造组件库：Menu 组件需求分析

以下均为伪代码：

```js
// 一个不那么完美的解决方案
const items = [
  {disabled:false,element:(<a>title</a>)},
  {disabled:true,element:'cool link'}
]
<Menu defaultIndex={0} items={items} onSelect={} mode="vertical"></Menu>
```

```js
// 更加语义化，更像 HTML 的解决方案
<Menu defaultIndex={0} onSelect={} mode="vertical">
  <Menu.item>title one</Menu.item>
  <Menu.item disabled>disabled link</Menu.item>
 <Menu.item><a href="https://www.google.com">Google!</a></Menu.item>
</Menu>
// 属性分析
interface MenuProps {
  activeIndex:number;
  mode: string;// 某种常量
  onSelect:(selectedIndex:number)=> voild
  className:string;
}
interface MenuItemProps {
  index:number;
  disabled: boolean;
  className:string;
}
```

(2)TS+React 打造组件库：基础架构 - Menu组件编码第一部分

```tsx
import React from 'react'
import classNames from 'classnames'

type MenuMode = 'horizontal' | 'vertical'
export interface MenuProps {
    defaultIndex?: number;
    className?: string;
    mode?: MenuMode;
    style?: React.CSSProperties;
    onSelect?: (selectedIndex: number) => void
}

const Menu: React.FC<MenuProps> = (props) => {
    const { defaultIndex, className, mode, style, children } = props
    const classes = classNames('jerrychane-menu', className, {
        'menu-vertical': mode === 'vertical'
    })
    return (
        <ul className={classes} style={style}>
            {children}
        </ul>
    )
}

Menu.defaultProps = {
    defaultIndex: 0,
    mode: 'horizontal'
}

export default Menu;
```

(3)TS+React 打造组件库：需求升级 - Menu 组件编码第二部分

#### 2021年02月23日 周二  09周

(1)TS+React 打造组件库：添加 Menu 样式

```html
https://css-tricks.com/snippets/css/a-guide-to-flexbox/
```

#### 2021年02月24日 周三  09周

(1)TS+React 打造组件库：测试驱动-Menu 测试添加

```tsx
//jerrychaneui/src/components/Menu/menu.test.tsx
import React from 'react'
import { cleanup, fireEvent, render, RenderResult } from '@testing-library/react'
import Menu, { MenuProps } from './menu'
import MenuItem from './menuItem'

const testProps: MenuProps = {
    defaultIndex: 0,
    onSelect: jest.fn(),
    className: 'test'
}

const testVerticalProps: MenuProps = {
    defaultIndex: 0,
    mode: 'vertical'
}

const generateMenu = (props: MenuProps) => {
    return (
        <Menu {...props}>
            <MenuItem index={0}>active</MenuItem>
            <MenuItem disabled index={1}>disabled</MenuItem>
            <MenuItem index={2}>xyz</MenuItem>
        </Menu>
    )
}
let wrapper: RenderResult, menuElement: HTMLElement, activeElement: HTMLElement, disabledElement: HTMLElement
describe('test Menu and MenuItem component', () => {
    beforeEach(() => {
        wrapper = render(generateMenu(testProps))
        menuElement = wrapper.getByTestId('test-menu')
        activeElement = wrapper.getByText('active')
        disabledElement = wrapper.getByText('disabled')
    })
    it('should render correct Menu and MenuItem based default props', () => {
        expect(menuElement).toBeInTheDocument()
        expect(menuElement).toHaveClass('viking-menu test')
        expect(menuElement.getElementsByTagName('li').length).toEqual(3)
        expect(activeElement).toHaveClass('menu-item is-active')
        expect(disabledElement).toHaveClass('menu-item is-disabled')

    })
    it('click items should change active and call the right callback', () => {
        const thirdItem = wrapper.getByText('xyz')
        fireEvent.click(thirdItem)
        expect(thirdItem).toHaveClass('is-active')
        expect(activeElement).not.toHaveClass('is-active')
        expect(testProps.onSelect).toHaveBeenCalledWith(2)
        fireEvent.click(disabledElement)
        expect(disabledElement).not.toHaveClass('is-active')
        expect(testProps.onSelect).not.toHaveBeenCalledWith(1)
    })
    it('should render vertical mode when mode is set to vertical', () => {
        cleanup()
        const wrapper = render(generateMenu(testVerticalProps))
        const menuElement = wrapper.getByTestId('test-menu')
        expect(menuElement).toHaveClass('menu-vertical')
    })
})
```

#### 2021年02月25日 周四  09周

(1)TS+React 打造组件库：日趋完美 - Menu 组件编码第三部分

```tsx
 const renderChildren = () => {
        return React.Children.map(children, (child, index) => {
            const childElement = child as React.FunctionComponentElement<MenuItemProps>
            const { displayName } = childElement.type
            if (displayName === "MenuItem") {
                return React.cloneElement(childElement, { index })
            } else {
                console.error('Warning: Menu has a child which is not a MenuItem component!')
            }
        })
    }
    return (
        <ul className={classes} style={style} data-testid="test-menu">
            <MenuContext.Provider value={passContext}>
                {renderChildren()}
            </MenuContext.Provider>
        </ul>
    )
```

#### 2021年02月27日 周六  09周

(1)TS+React 打造组件库：功能继续升级 - SubMenu 下拉菜单编码第一部分

```jsx
// 更加语义化 更加像 HTML 的解决方案
<Menu defaultIndex={0} onSelect={}>
  <Menu.Item index={"0"}>title one</Menu.Item>
  <Menu.Item disalbed  index={"1"}>disalbed link</Menu.Item>
  <Menu.SubMenu title={'test'}  index={"2"}> 
  	<Menu.Item index={"2-0"}>cool link</Menu.Item>
    <Menu.Item index={"2-1"}>cool link</Menu.Item>
  </Menu.SubMenu>
  <Menu.Item index={"3"}><a href="https://www.google.com">Google</a></Menu.Item>
</Menu>
```

(2)TS+React 打造组件库：添加交互 - SubMenu下拉菜单编码第二部分

```tsx
import React, { useContext, useState, FunctionComponentElement } from 'react'
import classNames from 'classnames'
import { MenuContext } from './menu'
import { MenuItemProps } from './menuItem'

export interface SubMenuProps {
    index?: number;
    title?: string;
    className?: string;
}

const SubMenu: React.FC<SubMenuProps> = ({ index, title, children, className }) => {
    const context = useContext(MenuContext)
    const [menuOpen, setOpen] = useState(false)
    const classes = classNames('menu-item submenu-item', className, {
        'is-active': context.index === index
    })
    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault()
        setOpen(!menuOpen)
    }
    let timer: any
    const handleMouse = (e: React.MouseEvent, toggle: boolean) => {
        clearTimeout(timer)
        e.preventDefault()
        timer = setTimeout(() => {
            setOpen(toggle)
        }, 300)
    }
    const clickEvents = context.mode === 'vertical' ? { onClick: handleClick } : {}
    const hoverEvents = context.mode !== 'vertical' ? {
        onMouseEnter: (e: React.MouseEvent) => { handleMouse(e, true) },
        onMouseLeave: (e: React.MouseEvent) => { handleMouse(e, false) },
    } : {}
    const renderChildren = () => {
        const subMenuClasses = classNames('viking-submenu', {
            'menu-opened': menuOpen
        })
        const childrenComponent = React.Children.map(children, (child, i) => {
            const childElement = child as FunctionComponentElement<MenuItemProps>
            if (childElement.type.displayName === "MenuItem") {
                return childElement
            } else {
                console.error('Warning:SubMenu has a child which is not a MenuItem component')
            }
        })
        return (
            <ul className={subMenuClasses}>{childrenComponent}</ul>
        )
    }
    return (
        <li key={index} className={classes} {...hoverEvents}>
            <div className='submenu-title' onClick={handleClick} {...clickEvents}>{title}</div>
            {renderChildren()}
        </li>
    )
}
SubMenu.displayName = 'SubMenu'
export default SubMenu
```

#### 2021年02月28日 周日  09周

(1)TS+React 打造组件库：大功告成 - SubMenu 下拉菜单编码第三部分

把 index 的类型要定义成 string 类型;

(2)TS+React 打造组件库：完美组件 - SubMenu 组件添加测试

```tsx
it('should show dropdown items when hover on subMenu', async () => {
        expect(wrapper.queryByText('drop1')).not.toBeVisible()
        const dropdownElement = wrapper.getByText('dropdown')
        fireEvent.mouseEnter(dropdownElement)
        await waitFor(() => {
            expect(wrapper.queryByText('drop1')).toBeVisible()
        })
        fireEvent.click(wrapper.getByText('drop1'))
        expect(testProps.onSelect).toHaveBeenCalledWith('3-0')
        fireEvent.mouseLeave(dropdownElement)
        await waitFor(() => {
            expect(wrapper.queryByText('drop1')).not.toBeVisible()
        })
    })
```













