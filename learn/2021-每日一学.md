#### 2020年01月08日 周五 第02周

(1)数据结构与算法：队列任务-代码操作

#### 2020年01月11日 周一 第03周

(1) React 源码深度解析： memo 组件的更新 & completeUnitWork的整体流程和意义。

- 根据是否中断调用不同的方法；
- 判断是否有兄弟节点来执行不同的操作；
- 完成节点之后赋值 effect 链；

（2）数据结构与算法：任务队列代码实操

```js
export default (tasks, n) => {
    // 声明一个变量记录最终任务的顺序
    let q = ''
    // 任务分类
    let Q = {}
    tasks.forEach(item => {
        if (Q[item]) {
            Q[item]++
        } else {
            Q[item]=1 
        }
    });
    while (1) {
        let keys = Object.keys(Q)
        if (!keys[0]) {
           break
        } 
        // n+1 为一组
        let tmp = []
        for (let i = 0; i <= n; i++) {
            let max = 0
            let key
            let pos
            // 从所有的任务中找到未处理数最大的优先安排
            keys.forEach((item, idx) => {
                if (Q[item] > max) {
                    max = Q[item]
                    key = item
                    pos = idx
                }
            })
            if (key) {
                tmp.push(key)
                keys.splice(pos, 1)
                Q[key]--
                if (Q[key] < 1) {
                    delete Q[key]
                }
            } else {
                break
            }
        }
        q+=tmp.join('').padEnd(n+1,'-')
    }
    // A--A--A-- 替换为 A--A--A
    q=q.replace(/-+$/g,'')
    return q.length
}
```

(3) 数据结构：排序链表 & 环形链表，重点是：如何手动创建一个链表的数据结构；知道链表如何排序；如何检测链表是闭环的。

排序链表：在O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例1：

```html
输入: 4->2->1->3
输出: 1->2->3->4
```

示例2：

```html
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

快速排序的本质：在遍历时选择一个基准元素，排序中的任何一个元素都可以作为基准元素，通常情况下选第一个就可以。把所有小于基准元素的元素，放在基准元素的左边；大于基准元素的元素，放在基准元素的右边；然后递归左边和右边的所有元素。

链表只会暴露一个头指针，所有的元素是不能直接访问到的，必须通过头指针不断地访问 next 对象，才能拿到具体的元素。设置两个指针p,q，都是指向头元素，p 指针左侧的元素是小于基准元素的，p 与 q 之间的元素是大于基准元素的。

#### 2020年01月12日 周二 第03周

(1) 高仿组件库:

> 参考网站：http://vikingship.xyz

- vikingship 是教学组件库，使用 React Hooks 和 typescript ；
- learning-typescript 为第二章 Typescript 入门源代码，只针对第二章；
- react-with-ts 为课程第三章，神奇的 React 源代码；

#### 2020年01月13日 周三 第03周

(1)数据结构与算法：链表的快速排序比堆排序使用的场景更多。

(2)数据结构与算法：环形链表-原理讲解

环形链表：给定一个链表，判断链表中是否有循环。为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1` ，则在该链表中没有环。

示例1：

```
输入：head = [3,2,0,-4],pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

(3) 环形链表-代码实操

#### 2020年01月14日 周四 第03周

(1) 数据结构与算法：螺旋矩阵 & 旋转图像

给定一个包含 m x n 个元素的矩阵（m行，n列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

示例1：

```
输入：
[
	[1,2,3],
	[4,5,6],
	[7,8,9]
]
输出：[1,2,3,6,9,8,7,4,5]
```

(2) 数据结构与算法：旋转图像

给定一个 n x n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例1：

```
给定 matrix = 
[
	[1,2,3],
	[4,5,6],
	[7,8,9]
]
原地旋转输入矩阵，使其变为：
[
	[7,4,1],
	[8,5,2],
	[9,6,3]
]
```

示例2：

```
给定 matrix = 
[
 [5,1,9,11],
 [2,4,8,10],
 [13,3,6,7],
 [15,14,12,16]
]
原地旋转输入矩阵，使其变为：
[
	[15,13,2,5],
	[14,3,4,1],
	[12,6,8,9],
	[16,7,10,11]
]
```

#### 2020年01月15日 周五 第03周

(1)数据结构与算法：旋转图像-代码实操

```js
export default (arr) => {
  // 获取 n 的维度
  let vecor = arr.length;
  // 垂直翻转
  for (let i = 0, len = vecor / 2; i < len; i++) {
    for (let j = 0, tmp; j < vecor; j++) {
      tmp = arr[i][j];
      arr[i][j] = arr[vecor - i - 1][j];
      arr[vecor - i - 1][j] = tmp;
    }
  }
  // 对角线翻转
  for (let i = 0; i < vecor; i++) {
    for (let j = 0, tmp; j < i; j++) {
      let tmp = arr[i][j];
      arr[i][j] = arr[j][i];
      arr[j][i] = tmp;
    }
  }
  return arr;
};
```

(2)数据结构与算法：对称二叉树-原理讲解，二叉树是出现频率很高，难度最大的数据结构。二叉树的特性之一是一个节点只有两个子节点，左节点和右节点。

给定一个二叉树，检查它是否是镜像对称。例如，二叉树 `[1,2,2,3,4,4,3] ` 是对称的。

```
	    1
	  /	 \
   2 		2
 /  \   / \
3   4  4   3
```

但是下面这个 `[1,2,2,null,3,null,3] ` 则不是镜像对称的：

```
		1
	/		\
	2		2
	\ 	\
	3 	3
```

(3) 数据结构与算法：对称二叉树-代码实操

```js
// 构造二叉树数据结构
// 二叉树的节点
class Node {
  constructor(val) {
    this.val = val;
    this.left = this.right = undefined;
  }
}
// 声明一个二叉树
class Tree {
  constructor(data) {
    // 临时存储所有节点，方便寻找父子节点
    let nodeList = [];
    // 顶节点
    let root;
    for (let i = 0, len = data.length; i < len; i++) {
      let node = new Node(data[i]);
      nodeList.push(node);
      if (i > 0) {
        // 计算当前节点属于哪一层
        let n = Math.floor(Math.sqrt(i + 1));
        // 记录当前层的起始点
        let q = Math.pow(2, n) - 1;
        // 记录上一层的起始点
        let p = Math.pow(2, n - 1) - 1;
        // 找到当前节点的父节点
        let parent = nodeList[p + Math.floor((i - q) / 2)];
        // 将当前节点和上一层的父节点做关联
        if (parent.left) {
          parent.right = node;
        } else {
          parent.left = node;
        }
      }
    }
    root = nodeList.shift();
    nodeList.length = 0;
    return root;
  }
  // 判断是否对称的静态方法
  static isSymmetry(root) {
    if (!root) {
      return true;
    }
    let walk = (left, right) => {
      if (!left && !right) {
        return true;
      }
      if ((left && !right) || (!left && right) || left.val !== right.val) {
        return false;
      }
      return walk(left.left, right.right) && walk(left.right, right.left);
    };
    return walk(root.left, root.right);
  }
}

export default Tree;
export { Node };
```

#### 2020年01月16日 周六 第03周

(1)数据结构与算法：验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

示例1：

```
输入：
 		2
 	/  \
 	1 	3
输出：true
```

(2)数据结构与算法：验证二叉搜索树-代码实操

```js
class Node {
  constructor(val) {
    this.val = val;
    this.left = this.right = undefined;
  }
}

class Tree {
  constructor(data) {
    let root = new Node(data.shift());
    //   遍历所有的数据，逐渐插入到当前这棵搜索树上
    data.forEach((item) => {
      this.insert(root, item);
    });
    return root;
  }
  insert(node, data) {
    if (node.val > data) {
      if (node.left === undefined) {
        node.left = new Node(data);
      } else {
        this.insert(node.left, data);
      }
    } else {
      if (node.right === undefined) {
        node.right = new Node(data);
      } else {
        this.insert(node.right, data);
      }
    }
  }
  static walk(root) {
    if (!root.left && !root.right) {
      return true;
    } else if (
      (root.left && root.val < root.left.val) ||
      (root.right && root.val > root.right.val)
    ) {
      return false;
    } else {
      return Tree.walk(root.left) && Tree.walk(root.right);
    }
  }
}

export default Tree;
export { Node };
```

(3)数据结构与算法：堆排序-原理讲解

