# 20210411-深入理解ES6

### 1.块级作用域绑定

> 讨论 var 在块级作用域中的替代方法 —— let 和 const。

预期输出数字 0~9,最初是在循环中使用立即调用函数表达式(IIFE)
```js
var funcs = [];

for(var i = 0; i < 10; i++) {
    funcs.push((function(){
        return function(value) {
            console.log(value)
        }
    }(i)));
}

funcs.forEach(function(func){
    func(); // 输出 0，然后是 1、2 ... 9
})
```
在循环内部，IIFE 表达式为为接受的每一个变量 i 都创建了一个副本并存储为变量 value。这个变量的值就是相应迭代创建的函数所使用的值。

#### 循环中的let声明
let 声明每次迭代循环都会创建一个新变量，并以之前迭代中同名变量的值将其初始化。
```js
var funcs = [];

for(let i = 0;i < 10; i++){
    funcs.push(function(){
        console.log(i)
    });
}

funcs.forEach(function(func){
    func();// 输出 0，然后是 1、2 ... 9
});
```
对于 for-in 循环和 for-of 循环也一样，每次循环的时候 let 声明都会创建一个新变量 i,并将其初始化为 i 的当前值，所循环内部创建的每个函数都能得到属于它们自己的 i 的副本。

```js
var funcs = [],obj = {a:true,b:true,c:true};

for(let key in obj){
    funcs.push(function(){
        console.log(key);
    });
}

funcs.forEach(function(func){
    func();//输出 a,b,c
});
```
#### 全局块作用域绑定

如果在全局作用域中使用 let 或 const，会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。即，let 或 const 不会覆盖全局变量。


```js
//在浏览器中
let RegExp = "Hello!";
console.log(RegExp);// "Hello!"
console.log(window.RegExp === RegExp);// false

const ncz = "Hi!";
console.log(ncz);// "Hi!"
console.log(window.RegExp === ncz);// false
```

#### 块级绑定最佳实践

当更多的开发者迁移到 ES6 后，日益普遍的做法是：默认是使用 `const`，只有确实需要改变变量的值时使用`let`。因为大部分的变量的值在初始化后不应再改变，而预料外的变量值的改变是很多 bug 的源头。

#### 小结

块级作用域绑定的`let`和`const` 为js引入了词法作用域，它们声明的变量不会提升，而且只可以在声明这些变量的代码块中使用，变量只会在需要它们的地方声明。与此同时，这一新特性还存在一个副作用，即不能在声明变量前访问它们，就算用`typeof`这样的安全操作符也不行。在声明前访问块级绑定会导致错误，因为绑定还在临时死区(TDZ)中。

`let`和`const` 的行为很多时候与`var`一致。然而，它们在循环中的行为却不一样。在`for-in` 和 `for-of` 循环中，`let`和`const`都会每次迭代时创建新绑定，从而使循环体内创建的函数可以访问到相应迭代的值，而非最后一次迭代的值。`let` 在 `for` 循环中同样如此，但在`for` 循环中使用`const` 声明则可能引发错误。

当前使用块级绑定的最佳实践是：默认使用`const`,只在确实需要改变变量的值时使用`let`。这样就可以在某种程度上实现代码的不可变，从而防止某些错误的产生。

### 2、字符串和正则表达式

> 介绍字符串模板，新增的操作与检查字符串的功能。

3、函数

> 箭头函数(Arrow Function)、默认参数(Default Parameters)、不定参数(Rest Parameters)等。

4、扩展对象的功能性

> 对象的创建、修改及使用，包括对象字面量语法的变化、新的反射方法。

5、解构：数据访问更便捷

> 分解对象和数组 —— 对象和数组的解构。

6、Symbol 和 Symbol属性

> 定义属性的新途径 —— Symbol。Symbol 是一种新的原始类型，用于创建外部无法直接访问的对象属性。

7、Set 集合与 Map 集合

> 四种新的集合类型：Set、WeakSet、Map、WeakMap。这四种类型为数组增添了新的语义、去重机制，以及专门为 JS 设计的内存管理机制，极大地扩展数组的实用性。

8、迭代器( Iterator )和生成器( Generator )

> 协助你更有效地处理集合数据(字符串、数组、Set集合、Map集合)

9、JavaScript 中的类

> 新增类语法，包括 class、extends、super 等

10、改进数组功能

> 对原生数组进行改动，有趣的变化为开发者带来新的体验。

11、Promise 与异步编程

> ES6 将 Promise 正式纳入标准并为其提供可用的 Polyfill。

12、代理(Proxy)与反射(Refection) API

> 开发者可以通过代理对象拦截每一个在对象中执行的操作，赋予了开发者空前的对象控制权。

13、用模块封装代码

> 详述 JavaScript 官方模块风格。



















